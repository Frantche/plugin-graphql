{"version":3,"file":"vuex-orm-graphql.umd.js","sources":["../node_modules/graphql/jsutils/invariant.js","../node_modules/graphql/language/source.js","../node_modules/graphql/language/location.js","../node_modules/graphql/error/printError.js","../node_modules/graphql/error/GraphQLError.js","../node_modules/graphql/error/syntaxError.js","../node_modules/graphql/error/locatedError.js","../node_modules/graphql/error/formatError.js","../node_modules/graphql/error/index.js","../node_modules/graphql/language/blockStringValue.js","../node_modules/graphql/language/lexer.js","../node_modules/graphql/language/kinds.js","../node_modules/graphql/language/directiveLocation.js","../node_modules/graphql/language/parser.js","../node_modules/graphql/language/visitor.js","../node_modules/graphql/language/printer.js","../node_modules/lodash.isequal/index.js","../src/support/utils.ts","../src/common/logger.ts","../src/orm/model.ts","../node_modules/fast-json-stable-stringify/index.js","../node_modules/apollo-utilities/src/storeUtils.ts","../node_modules/apollo-utilities/src/directives.ts","../node_modules/apollo-utilities/src/fragments.ts","../node_modules/apollo-utilities/src/util/assign.ts","../node_modules/apollo-utilities/src/getFromAST.ts","../node_modules/fclone/dist/fclone.js","../node_modules/apollo-utilities/src/util/cloneDeep.ts","../node_modules/apollo-utilities/src/transform.ts","../node_modules/apollo-utilities/src/util/environment.ts","../node_modules/apollo-utilities/src/util/errorHandling.ts","../node_modules/apollo-utilities/src/util/isEqual.ts","../node_modules/apollo-utilities/src/util/warnOnce.ts","../node_modules/src/core/networkStatus.ts","../node_modules/zen-observable/lib/Observable.js","../node_modules/zen-observable-ts/src/zenObservable.ts","../node_modules/zen-observable/index.js","../node_modules/apollo-link/src/linkUtils.ts","../node_modules/apollo-link/src/link.ts","../node_modules/symbol-observable/es/index.js","../node_modules/symbol-observable/es/ponyfill.js","../node_modules/src/util/Observable.ts","../node_modules/src/errors/ApolloError.ts","../node_modules/src/core/types.ts","../node_modules/src/core/ObservableQuery.ts","../node_modules/apollo-link-dedup/src/dedupLink.ts","../node_modules/src/scheduler/scheduler.ts","../node_modules/src/data/mutations.ts","../node_modules/src/data/queries.ts","../node_modules/src/core/QueryManager.ts","../node_modules/src/data/store.ts","../node_modules/apollo-client/version.js","../node_modules/src/ApolloClient.ts","../node_modules/apollo-cache/src/utils.ts","../node_modules/apollo-cache/src/cache.ts","../node_modules/apollo-cache-inmemory/src/fragmentMatcher.ts","../node_modules/apollo-cache-inmemory/src/objectCache.ts","../node_modules/apollo-cache-inmemory/src/writeToStore.ts","../node_modules/graphql-anywhere/src/graphql.ts","../node_modules/apollo-cache-inmemory/src/readFromStore.ts","../node_modules/apollo-cache-inmemory/src/recordingCache.ts","../node_modules/apollo-cache-inmemory/src/inMemoryCache.ts","../node_modules/apollo-link-http-common/src/index.ts","../node_modules/apollo-link-http/src/httpLink.ts","../src/graphql/transformer.ts","../node_modules/graphql-tag/src/index.js","../src/graphql/apollo.ts","../src/graphql/schema.ts","../src/common/context.ts","../src/graphql/query-builder.ts","../src/orm/store.ts","../src/graphql/name-generator.ts","../src/actions/action.ts","../src/actions/destroy.ts","../src/actions/fetch.ts","../src/actions/mutate.ts","../src/actions/persist.ts","../src/actions/push.ts","../src/actions/query.ts","../src/actions/simple-query.ts","../src/actions/simple-mutation.ts","../src/vuex-orm-graphql.ts"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = invariant;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction invariant(condition, message) {\n  /* istanbul ignore else */\n  if (!condition) {\n    throw new Error(message);\n  }\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Source = undefined;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                           *\n                                                                                                                                                           * This source code is licensed under the MIT license found in the\n                                                                                                                                                           * LICENSE file in the root directory of this source tree.\n                                                                                                                                                           *\n                                                                                                                                                           * \n                                                                                                                                                           */\n\n/**\n * A representation of source input to GraphQL.\n * `name` and `locationOffset` are optional. They are useful for clients who\n * store GraphQL documents in source files; for example, if the GraphQL input\n * starts at line 40 in a file named Foo.graphql, it might be useful for name to\n * be \"Foo.graphql\" and location to be `{ line: 40, column: 0 }`.\n * line and column in locationOffset are 1-indexed\n */\nvar Source = exports.Source = function Source(body, name, locationOffset) {\n  _classCallCheck(this, Source);\n\n  this.body = body;\n  this.name = name || 'GraphQL request';\n  this.locationOffset = locationOffset || { line: 1, column: 1 };\n  !(this.locationOffset.line > 0) ? (0, _invariant2.default)(0, 'line in locationOffset is 1-indexed and must be positive') : void 0;\n  !(this.locationOffset.column > 0) ? (0, _invariant2.default)(0, 'column in locationOffset is 1-indexed and must be positive') : void 0;\n};","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLocation = getLocation;\n\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match = void 0;\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n  return { line: line, column: column };\n}\n\n/**\n * Represents a location in a Source.\n */","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printError = printError;\n\nvar _location = require('../language/location');\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\nfunction printError(error) {\n  var printedLocations = [];\n  if (error.nodes) {\n    error.nodes.forEach(function (node) {\n      if (node.loc) {\n        printedLocations.push(highlightSourceAtLocation(node.loc.source, (0, _location.getLocation)(node.loc.source, node.loc.start)));\n      }\n    });\n  } else if (error.source && error.locations) {\n    var source = error.source;\n    error.locations.forEach(function (location) {\n      printedLocations.push(highlightSourceAtLocation(source, location));\n    });\n  }\n  return printedLocations.length === 0 ? error.message : [error.message].concat(printedLocations).join('\\n\\n') + '\\n';\n}\n\n/**\n * Render a helpful description of the location of the error in the GraphQL\n * Source document.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction highlightSourceAtLocation(source, location) {\n  var line = location.line;\n  var lineOffset = source.locationOffset.line - 1;\n  var columnOffset = getColumnOffset(source, location);\n  var contextLine = line + lineOffset;\n  var contextColumn = location.column + columnOffset;\n  var prevLineNum = (contextLine - 1).toString();\n  var lineNum = contextLine.toString();\n  var nextLineNum = (contextLine + 1).toString();\n  var padLen = nextLineNum.length;\n  var lines = source.body.split(/\\r\\n|[\\n\\r]/g);\n  lines[0] = whitespace(source.locationOffset.column - 1) + lines[0];\n  var outputLines = [source.name + ' (' + contextLine + ':' + contextColumn + ')', line >= 2 && lpad(padLen, prevLineNum) + ': ' + lines[line - 2], lpad(padLen, lineNum) + ': ' + lines[line - 1], whitespace(2 + padLen + contextColumn - 1) + '^', line < lines.length && lpad(padLen, nextLineNum) + ': ' + lines[line]];\n  return outputLines.filter(Boolean).join('\\n');\n}\n\nfunction getColumnOffset(source, location) {\n  return location.line === 1 ? source.locationOffset.column - 1 : 0;\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLError = GraphQLError;\n\nvar _printError = require('./printError');\n\nvar _location = require('../language/location');\n\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined;\n\n  // Compute locations in the source for the given nodes/positions.\n  var _source = source;\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n      return list;\n    }, []);\n  }\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations = void 0;\n  if (positions && source) {\n    var providedSource = source;\n    _locations = positions.map(function (pos) {\n      return (0, _location.getLocation)(providedSource, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push((0, _location.getLocation)(node.loc.source, node.loc.start));\n      }\n      return list;\n    }, []);\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      value: extensions || originalError && originalError.extensions\n    }\n  });\n\n  // Include (non-enumerable) stack trace.\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: { value: GraphQLError },\n  name: { value: 'GraphQLError' },\n  toString: {\n    value: function toString() {\n      return (0, _printError.printError)(this);\n    }\n  }\n});","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.syntaxError = syntaxError;\n\nvar _GraphQLError = require('./GraphQLError');\n\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction syntaxError(source, position, description) {\n  return new _GraphQLError.GraphQLError('Syntax Error: ' + description, undefined, source, [position]);\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.locatedError = locatedError;\n\nvar _GraphQLError = require('./GraphQLError');\n\n/**\n * Given an arbitrary Error, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\nfunction locatedError(originalError, nodes, path) {\n  // Note: this uses a brand-check to support GraphQL errors originating from\n  // other contexts.\n  if (originalError && Array.isArray(originalError.path)) {\n    return originalError;\n  }\n\n  return new _GraphQLError.GraphQLError(originalError && originalError.message, originalError && originalError.nodes || nodes, originalError && originalError.source, originalError && originalError.positions, path, originalError);\n} /**\n   * Copyright (c) 2015-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * \n   */","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**\n                                                                                                                                                                                                                                                                   * Copyright (c) 2015-present, Facebook, Inc.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   * This source code is licensed under the MIT license found in the\n                                                                                                                                                                                                                                                                   * LICENSE file in the root directory of this source tree.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   * \n                                                                                                                                                                                                                                                                   */\n\nexports.formatError = formatError;\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n */\nfunction formatError(error) {\n  !error ? (0, _invariant2.default)(0, 'Received null or undefined error.') : void 0;\n  return _extends({}, error.extensions, {\n    message: error.message || 'An unknown error occurred.',\n    locations: error.locations,\n    path: error.path\n  });\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _GraphQLError = require('./GraphQLError');\n\nObject.defineProperty(exports, 'GraphQLError', {\n  enumerable: true,\n  get: function get() {\n    return _GraphQLError.GraphQLError;\n  }\n});\n\nvar _syntaxError = require('./syntaxError');\n\nObject.defineProperty(exports, 'syntaxError', {\n  enumerable: true,\n  get: function get() {\n    return _syntaxError.syntaxError;\n  }\n});\n\nvar _locatedError = require('./locatedError');\n\nObject.defineProperty(exports, 'locatedError', {\n  enumerable: true,\n  get: function get() {\n    return _locatedError.locatedError;\n  }\n});\n\nvar _printError = require('./printError');\n\nObject.defineProperty(exports, 'printError', {\n  enumerable: true,\n  get: function get() {\n    return _printError.printError;\n  }\n});\n\nvar _formatError = require('./formatError');\n\nObject.defineProperty(exports, 'formatError', {\n  enumerable: true,\n  get: function get() {\n    return _formatError.formatError;\n  }\n});","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = blockStringValue;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * Coffeescript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nfunction blockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n\n  // Remove common indentation from all lines but first.\n  var commonIndent = null;\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n    if (indent < line.length && (commonIndent === null || indent < commonIndent)) {\n      commonIndent = indent;\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  if (commonIndent) {\n    for (var _i = 1; _i < lines.length; _i++) {\n      lines[_i] = lines[_i].slice(commonIndent);\n    }\n  }\n\n  // Remove leading and trailing blank lines.\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  }\n\n  // Return a string of the lines joined with U+000A.\n  return lines.join('\\n');\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenKind = undefined;\nexports.createLexer = createLexer;\nexports.getTokenDesc = getTokenDesc;\n\nvar _error = require('../error');\n\nvar _blockStringValue = require('./blockStringValue');\n\nvar _blockStringValue2 = _interopRequireDefault(_blockStringValue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction createLexer(source, options) {\n  var startOfFileToken = new Tok(SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer,\n    lookahead: lookahead\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  var token = this.token = this.lookahead();\n  return token;\n}\n\nfunction lookahead() {\n  var token = this.token;\n  if (token.kind !== EOF) {\n    do {\n      // Note: next is only mutable during parsing, so we cast to allow this.\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === COMMENT);\n  }\n  return token;\n}\n\n/**\n * The return type of createLexer.\n */\n\n\n// Each kind of token.\nvar SOF = '<SOF>';\nvar EOF = '<EOF>';\nvar BANG = '!';\nvar DOLLAR = '$';\nvar PAREN_L = '(';\nvar PAREN_R = ')';\nvar SPREAD = '...';\nvar COLON = ':';\nvar EQUALS = '=';\nvar AT = '@';\nvar BRACKET_L = '[';\nvar BRACKET_R = ']';\nvar BRACE_L = '{';\nvar PIPE = '|';\nvar BRACE_R = '}';\nvar NAME = 'Name';\nvar INT = 'Int';\nvar FLOAT = 'Float';\nvar STRING = 'String';\nvar BLOCK_STRING = 'BlockString';\nvar COMMENT = 'Comment';\n\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind = exports.TokenKind = {\n  SOF: SOF,\n  EOF: EOF,\n  BANG: BANG,\n  DOLLAR: DOLLAR,\n  PAREN_L: PAREN_L,\n  PAREN_R: PAREN_R,\n  SPREAD: SPREAD,\n  COLON: COLON,\n  EQUALS: EQUALS,\n  AT: AT,\n  BRACKET_L: BRACKET_L,\n  BRACKET_R: BRACKET_R,\n  BRACE_L: BRACE_L,\n  PIPE: PIPE,\n  BRACE_R: BRACE_R,\n  NAME: NAME,\n  INT: INT,\n  FLOAT: FLOAT,\n  STRING: STRING,\n  BLOCK_STRING: BLOCK_STRING,\n  COMMENT: COMMENT\n};\n\n/**\n * A helper function to describe a token as a string for debugging\n */\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? token.kind + ' \"' + value + '\"' : token.kind;\n}\n\nvar charCodeAt = String.prototype.charCodeAt;\nvar slice = String.prototype.slice;\n\n/**\n * Helper function for constructing the Token object.\n */\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nTok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n};\n\nfunction printCharCode(code) {\n  return (\n    // NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    '\"\\\\u' + ('00' + code.toString(16).toUpperCase()).slice(-4) + '\"'\n  );\n}\n\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace and comments until it finds the next lexable\n * token, then lexes punctuators immediately or calls the appropriate helper\n * function for more complicated tokens.\n */\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n\n  var position = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + position - lexer.lineStart;\n\n  if (position >= bodyLength) {\n    return new Tok(EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = charCodeAt.call(body, position);\n\n  // SourceCharacter\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    throw (0, _error.syntaxError)(source, position, 'Cannot contain the invalid character ' + printCharCode(code) + '.');\n  }\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(BANG, position, position + 1, line, col, prev);\n    // #\n    case 35:\n      return readComment(source, position, line, col, prev);\n    // $\n    case 36:\n      return new Tok(DOLLAR, position, position + 1, line, col, prev);\n    // (\n    case 40:\n      return new Tok(PAREN_L, position, position + 1, line, col, prev);\n    // )\n    case 41:\n      return new Tok(PAREN_R, position, position + 1, line, col, prev);\n    // .\n    case 46:\n      if (charCodeAt.call(body, position + 1) === 46 && charCodeAt.call(body, position + 2) === 46) {\n        return new Tok(SPREAD, position, position + 3, line, col, prev);\n      }\n      break;\n    // :\n    case 58:\n      return new Tok(COLON, position, position + 1, line, col, prev);\n    // =\n    case 61:\n      return new Tok(EQUALS, position, position + 1, line, col, prev);\n    // @\n    case 64:\n      return new Tok(AT, position, position + 1, line, col, prev);\n    // [\n    case 91:\n      return new Tok(BRACKET_L, position, position + 1, line, col, prev);\n    // ]\n    case 93:\n      return new Tok(BRACKET_R, position, position + 1, line, col, prev);\n    // {\n    case 123:\n      return new Tok(BRACE_L, position, position + 1, line, col, prev);\n    // |\n    case 124:\n      return new Tok(PIPE, position, position + 1, line, col, prev);\n    // }\n    case 125:\n      return new Tok(BRACE_R, position, position + 1, line, col, prev);\n    // A-Z _ a-z\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, position, line, col, prev);\n    // - 0-9\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, position, code, line, col, prev);\n    // \"\n    case 34:\n      if (charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34) {\n        return readBlockString(source, position, line, col, prev);\n      }\n      return readString(source, position, line, col, prev);\n  }\n\n  throw (0, _error.syntaxError)(source, position, unexpectedCharacterMessage(code));\n}\n\n/**\n * Report a message that an unexpected character was encountered.\n */\nfunction unexpectedCharacterMessage(code) {\n  if (code === 39) {\n    // '\n    return \"Unexpected single quote character ('), did you mean to use \" + 'a double quote (\")?';\n  }\n\n  return 'Cannot parse the unexpected character ' + printCharCode(code) + '.';\n}\n\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * or commented character, then returns the position of that character for\n * lexing.\n */\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n  while (position < bodyLength) {\n    var code = charCodeAt.call(body, position);\n    // tab | space | comma | BOM\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (charCodeAt.call(body, position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n  return position;\n}\n\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code = void 0;\n  var position = start;\n\n  do {\n    code = charCodeAt.call(body, ++position);\n  } while (code !== null && (\n  // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Tok(COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));\n}\n\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = charCodeAt.call(body, ++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = charCodeAt.call(body, ++position);\n    if (code >= 48 && code <= 57) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid number, unexpected digit after 0: ' + printCharCode(code) + '.');\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    if (code === 43 || code === 45) {\n      // + -\n      code = charCodeAt.call(body, ++position);\n    }\n    position = readDigits(source, position, code);\n  }\n\n  return new Tok(isFloat ? FLOAT : INT, start, position, line, col, prev, slice.call(body, start, position));\n}\n\n/**\n * Returns the new position in the source after reading digits.\n */\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = charCodeAt.call(body, ++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n    return position;\n  }\n  throw (0, _error.syntaxError)(source, position, 'Invalid number, expected digit but got: ' + printCharCode(code) + '.');\n}\n\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null &&\n  // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += slice.call(body, chunkStart, position);\n      return new Tok(STRING, start, position + 1, line, col, prev, value);\n    }\n\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');\n    }\n\n    ++position;\n    if (code === 92) {\n      // \\\n      value += slice.call(body, chunkStart, position - 1);\n      code = charCodeAt.call(body, position);\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n        case 47:\n          value += '/';\n          break;\n        case 92:\n          value += '\\\\';\n          break;\n        case 98:\n          value += '\\b';\n          break;\n        case 102:\n          value += '\\f';\n          break;\n        case 110:\n          value += '\\n';\n          break;\n        case 114:\n          value += '\\r';\n          break;\n        case 116:\n          value += '\\t';\n          break;\n        case 117:\n          // u\n          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));\n          if (charCode < 0) {\n            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + ('\\\\u' + body.slice(position + 1, position + 5) + '.'));\n          }\n          value += String.fromCharCode(charCode);\n          position += 4;\n          break;\n        default:\n          throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: \\\\' + String.fromCharCode(code) + '.');\n      }\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n}\n\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\nfunction readBlockString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34) {\n      rawValue += slice.call(body, chunkStart, position);\n      return new Tok(BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockStringValue2.default)(rawValue));\n    }\n\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw (0, _error.syntaxError)(source, position, 'Invalid character within String: ' + printCharCode(code) + '.');\n    }\n\n    // Escape Triple-Quote (\\\"\"\")\n    if (code === 92 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34 && charCodeAt.call(body, position + 3) === 34) {\n      rawValue += slice.call(body, chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n}\n\n/**\n * Converts four hexidecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\nfunction readName(source, position, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var end = position + 1;\n  var code = 0;\n  while (end !== bodyLength && (code = charCodeAt.call(body, end)) !== null && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++end;\n  }\n  return new Tok(NAME, position, end, line, col, prev, slice.call(body, position, end));\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n// Name\n\nvar NAME = exports.NAME = 'Name';\n\n// Document\n\nvar DOCUMENT = exports.DOCUMENT = 'Document';\nvar OPERATION_DEFINITION = exports.OPERATION_DEFINITION = 'OperationDefinition';\nvar VARIABLE_DEFINITION = exports.VARIABLE_DEFINITION = 'VariableDefinition';\nvar VARIABLE = exports.VARIABLE = 'Variable';\nvar SELECTION_SET = exports.SELECTION_SET = 'SelectionSet';\nvar FIELD = exports.FIELD = 'Field';\nvar ARGUMENT = exports.ARGUMENT = 'Argument';\n\n// Fragments\n\nvar FRAGMENT_SPREAD = exports.FRAGMENT_SPREAD = 'FragmentSpread';\nvar INLINE_FRAGMENT = exports.INLINE_FRAGMENT = 'InlineFragment';\nvar FRAGMENT_DEFINITION = exports.FRAGMENT_DEFINITION = 'FragmentDefinition';\n\n// Values\n\nvar INT = exports.INT = 'IntValue';\nvar FLOAT = exports.FLOAT = 'FloatValue';\nvar STRING = exports.STRING = 'StringValue';\nvar BOOLEAN = exports.BOOLEAN = 'BooleanValue';\nvar NULL = exports.NULL = 'NullValue';\nvar ENUM = exports.ENUM = 'EnumValue';\nvar LIST = exports.LIST = 'ListValue';\nvar OBJECT = exports.OBJECT = 'ObjectValue';\nvar OBJECT_FIELD = exports.OBJECT_FIELD = 'ObjectField';\n\n// Directives\n\nvar DIRECTIVE = exports.DIRECTIVE = 'Directive';\n\n// Types\n\nvar NAMED_TYPE = exports.NAMED_TYPE = 'NamedType';\nvar LIST_TYPE = exports.LIST_TYPE = 'ListType';\nvar NON_NULL_TYPE = exports.NON_NULL_TYPE = 'NonNullType';\n\n// Type System Definitions\n\nvar SCHEMA_DEFINITION = exports.SCHEMA_DEFINITION = 'SchemaDefinition';\nvar OPERATION_TYPE_DEFINITION = exports.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition';\n\n// Type Definitions\n\nvar SCALAR_TYPE_DEFINITION = exports.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition';\nvar OBJECT_TYPE_DEFINITION = exports.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition';\nvar FIELD_DEFINITION = exports.FIELD_DEFINITION = 'FieldDefinition';\nvar INPUT_VALUE_DEFINITION = exports.INPUT_VALUE_DEFINITION = 'InputValueDefinition';\nvar INTERFACE_TYPE_DEFINITION = exports.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition';\nvar UNION_TYPE_DEFINITION = exports.UNION_TYPE_DEFINITION = 'UnionTypeDefinition';\nvar ENUM_TYPE_DEFINITION = exports.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition';\nvar ENUM_VALUE_DEFINITION = exports.ENUM_VALUE_DEFINITION = 'EnumValueDefinition';\nvar INPUT_OBJECT_TYPE_DEFINITION = exports.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition';\n\n// Type Extensions\n\nvar SCALAR_TYPE_EXTENSION = exports.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension';\nvar OBJECT_TYPE_EXTENSION = exports.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension';\nvar INTERFACE_TYPE_EXTENSION = exports.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension';\nvar UNION_TYPE_EXTENSION = exports.UNION_TYPE_EXTENSION = 'UnionTypeExtension';\nvar ENUM_TYPE_EXTENSION = exports.ENUM_TYPE_EXTENSION = 'EnumTypeExtension';\nvar INPUT_OBJECT_TYPE_EXTENSION = exports.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension';\n\n// Directive Definitions\n\nvar DIRECTIVE_DEFINITION = exports.DIRECTIVE_DEFINITION = 'DirectiveDefinition';","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation = exports.DirectiveLocation = {\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n};\n\n/**\n * The enum type representing the directive location values.\n */","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\nexports.parseConstValue = parseConstValue;\nexports.parseTypeReference = parseTypeReference;\nexports.parseNamedType = parseNamedType;\n\nvar _source = require('./source');\n\nvar _error = require('../error');\n\nvar _lexer = require('./lexer');\n\nvar _kinds = require('./kinds');\n\nvar _directiveLocation = require('./directiveLocation');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\n\n/**\n * Configuration options to control parser behavior\n */\nfunction parse(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError('Must provide Source. Received: ' + String(sourceObj));\n  }\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction parseValue(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var value = parseValueLiteral(lexer, false);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return value;\n}\n\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\nfunction parseType(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var type = parseTypeReference(lexer);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return type;\n}\n\n/**\n * Converts a name lex token into a name parse node.\n */\nfunction parseName(lexer) {\n  var token = expect(lexer, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.NAME,\n    value: token.value,\n    loc: loc(lexer, token)\n  };\n}\n\n// Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\nfunction parseDocument(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SOF);\n  var definitions = [];\n  do {\n    definitions.push(parseDefinition(lexer));\n  } while (!skip(lexer, _lexer.TokenKind.EOF));\n\n  return {\n    kind: _kinds.DOCUMENT,\n    definitions: definitions,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Definition :\n *   - ExecutableDefinition\n *   - TypeSystemDefinition\n */\nfunction parseDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n      case 'fragment':\n        return parseExecutableDefinition(lexer);\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive':\n        // Note: The schema definition language is an experimental addition.\n        return parseTypeSystemDefinition(lexer);\n    }\n  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseExecutableDefinition(lexer);\n  } else if (peekDescription(lexer)) {\n    // Note: The schema definition language is an experimental addition.\n    return parseTypeSystemDefinition(lexer);\n  }\n\n  throw unexpected(lexer);\n}\n\n/**\n * ExecutableDefinition :\n *   - OperationDefinition\n *   - FragmentDefinition\n */\nfunction parseExecutableDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment':\n        return parseFragmentDefinition(lexer);\n    }\n  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  throw unexpected(lexer);\n}\n\n// Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\nfunction parseOperationDefinition(lexer) {\n  var start = lexer.token;\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.OPERATION_DEFINITION,\n      operation: 'query',\n      name: undefined,\n      variableDefinitions: [],\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  var operation = parseOperationType(lexer);\n  var name = void 0;\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n  return {\n    kind: _kinds.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationType : one of query mutation subscription\n */\nfunction parseOperationType(lexer) {\n  var operationToken = expect(lexer, _lexer.TokenKind.NAME);\n  switch (operationToken.value) {\n    case 'query':\n      return 'query';\n    case 'mutation':\n      return 'mutation';\n    case 'subscription':\n      return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\nfunction parseVariableDefinitions(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\nfunction parseVariableDefinition(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Variable : $ Name\n */\nfunction parseVariable(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * SelectionSet : { Selection+ }\n */\nfunction parseSelectionSet(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.SELECTION_SET,\n    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\nfunction parseSelection(lexer) {\n  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);\n}\n\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\nfunction parseField(lexer) {\n  var start = lexer.token;\n\n  var nameOrAlias = parseName(lexer);\n  var alias = void 0;\n  var name = void 0;\n  if (skip(lexer, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(lexer, false),\n    directives: parseDirectives(lexer, false),\n    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : undefined,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Arguments[Const] : ( Argument[?Const]+ )\n */\nfunction parseArguments(lexer, isConst) {\n  var item = isConst ? parseConstArgument : parseArgument;\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, item, _lexer.TokenKind.PAREN_R) : [];\n}\n\n/**\n * Argument[Const] : Name : Value[?Const]\n */\nfunction parseArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n}\n\nfunction parseConstArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseConstValue(lexer)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\nfunction parseFragment(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SPREAD);\n  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: _kinds.FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer, false),\n      loc: loc(lexer, start)\n    };\n  }\n  var typeCondition = void 0;\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n  return {\n    kind: _kinds.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\nfunction parseFragmentDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'fragment');\n  // Experimental support for defining variables within fragments changes\n  // the grammar of FragmentDefinition:\n  //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n  if (lexer.options.experimentalFragmentVariables) {\n    return {\n      kind: _kinds.FRAGMENT_DEFINITION,\n      name: parseFragmentName(lexer),\n      variableDefinitions: parseVariableDefinitions(lexer),\n      typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n      directives: parseDirectives(lexer, false),\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  return {\n    kind: _kinds.FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentName : Name but not `on`\n */\nfunction parseFragmentName(lexer) {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n  return parseName(lexer);\n}\n\n// Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - NullValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * NullValue : `null`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\nfunction parseValueLiteral(lexer, isConst) {\n  var token = lexer.token;\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n    case _lexer.TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: _kinds.INT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: _kinds.FLOAT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.STRING:\n    case _lexer.TokenKind.BLOCK_STRING:\n      return parseStringLiteral(lexer);\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: _kinds.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value === 'null') {\n        lexer.advance();\n        return {\n          kind: _kinds.NULL,\n          loc: loc(lexer, token)\n        };\n      }\n      lexer.advance();\n      return {\n        kind: _kinds.ENUM,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n      break;\n  }\n  throw unexpected(lexer);\n}\n\nfunction parseStringLiteral(lexer) {\n  var token = lexer.token;\n  lexer.advance();\n  return {\n    kind: _kinds.STRING,\n    value: token.value,\n    block: token.kind === _lexer.TokenKind.BLOCK_STRING,\n    loc: loc(lexer, token)\n  };\n}\n\nfunction parseConstValue(lexer) {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer) {\n  return parseValueLiteral(lexer, false);\n}\n\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\nfunction parseList(lexer, isConst) {\n  var start = lexer.token;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.LIST,\n    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\nfunction parseObject(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n  return {\n    kind: _kinds.OBJECT,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\nfunction parseObjectField(lexer, isConst) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.OBJECT_FIELD,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Directives section.\n\n/**\n * Directives[Const] : Directive[?Const]+\n */\nfunction parseDirectives(lexer, isConst) {\n  var directives = [];\n  while (peek(lexer, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(lexer, isConst));\n  }\n  return directives;\n}\n\n/**\n * Directive[Const] : @ Name Arguments[?Const]?\n */\nfunction parseDirective(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer, isConst),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\nfunction parseTypeReference(lexer) {\n  var start = lexer.token;\n  var type = void 0;\n  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {\n    type = parseTypeReference(lexer);\n    expect(lexer, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.LIST_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  } else {\n    type = parseNamedType(lexer);\n  }\n  if (skip(lexer, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.NON_NULL_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  }\n  return type;\n}\n\n/**\n * NamedType : Name\n */\nfunction parseNamedType(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n// Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtension\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeSystemDefinition(lexer) {\n  // Many definitions begin with a description and require a lookahead.\n  var keywordToken = peekDescription(lexer) ? lexer.lookahead() : lexer.token;\n\n  if (keywordToken.kind === _lexer.TokenKind.NAME) {\n    switch (keywordToken.value) {\n      case 'schema':\n        return parseSchemaDefinition(lexer);\n      case 'scalar':\n        return parseScalarTypeDefinition(lexer);\n      case 'type':\n        return parseObjectTypeDefinition(lexer);\n      case 'interface':\n        return parseInterfaceTypeDefinition(lexer);\n      case 'union':\n        return parseUnionTypeDefinition(lexer);\n      case 'enum':\n        return parseEnumTypeDefinition(lexer);\n      case 'input':\n        return parseInputObjectTypeDefinition(lexer);\n      case 'extend':\n        return parseTypeExtension(lexer);\n      case 'directive':\n        return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer, keywordToken);\n}\n\nfunction peekDescription(lexer) {\n  return peek(lexer, _lexer.TokenKind.STRING) || peek(lexer, _lexer.TokenKind.BLOCK_STRING);\n}\n\n/**\n * Description : StringValue\n */\nfunction parseDescription(lexer) {\n  if (peekDescription(lexer)) {\n    return parseStringLiteral(lexer);\n  }\n}\n\n/**\n * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n */\nfunction parseSchemaDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer, true);\n  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.SCHEMA_DEFINITION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationTypeDefinition : OperationType : NamedType\n */\nfunction parseOperationTypeDefinition(lexer) {\n  var start = lexer.token;\n  var operation = parseOperationType(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseNamedType(lexer);\n  return {\n    kind: _kinds.OPERATION_TYPE_DEFINITION,\n    operation: operation,\n    type: type,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n */\nfunction parseScalarTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.SCALAR_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectTypeDefinition :\n *   Description?\n *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n */\nfunction parseObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  return {\n    kind: _kinds.OBJECT_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ImplementsInterfaces : implements NamedType+\n */\nfunction parseImplementsInterfaces(lexer) {\n  var types = [];\n  if (lexer.token.value === 'implements') {\n    lexer.advance();\n    do {\n      types.push(parseNamedType(lexer));\n    } while (peek(lexer, _lexer.TokenKind.NAME));\n  }\n  return types;\n}\n\n/**\n * FieldsDefinition : { FieldDefinition+ }\n */\nfunction parseFieldsDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * FieldDefinition :\n *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n */\nfunction parseFieldDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.FIELD_DEFINITION,\n    description: description,\n    name: name,\n    arguments: args,\n    type: type,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\nfunction parseArgumentDefs(lexer) {\n  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n\n/**\n * InputValueDefinition :\n *   - Description? Name : Type DefaultValue? Directives[Const]?\n */\nfunction parseInputValueDef(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var defaultValue = void 0;\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.INPUT_VALUE_DEFINITION,\n    description: description,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InterfaceTypeDefinition :\n *   - Description? interface Name Directives[Const]? FieldsDefinition?\n */\nfunction parseInterfaceTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  return {\n    kind: _kinds.INTERFACE_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionTypeDefinition :\n *   - Description? union Name Directives[Const]? MemberTypesDefinition?\n */\nfunction parseUnionTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var types = parseMemberTypesDefinition(lexer);\n  return {\n    kind: _kinds.UNION_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * MemberTypesDefinition : = MemberTypes\n *\n * MemberTypes :\n *   - `|`? NamedType\n *   - MemberTypes | NamedType\n */\nfunction parseMemberTypesDefinition(lexer) {\n  var types = [];\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    // Optional leading pipe\n    skip(lexer, _lexer.TokenKind.PIPE);\n    do {\n      types.push(parseNamedType(lexer));\n    } while (skip(lexer, _lexer.TokenKind.PIPE));\n  }\n  return types;\n}\n\n/**\n * EnumTypeDefinition :\n *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n */\nfunction parseEnumTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var values = parseEnumValuesDefinition(lexer);\n  return {\n    kind: _kinds.ENUM_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * EnumValuesDefinition : { EnumValueDefinition+ }\n */\nfunction parseEnumValuesDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * EnumValueDefinition : Description? EnumValue Directives[Const]?\n *\n * EnumValue : Name\n */\nfunction parseEnumValueDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.ENUM_VALUE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputObjectTypeDefinition :\n *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n */\nfunction parseInputObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseInputFieldsDefinition(lexer);\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputFieldsDefinition : { InputValueDefinition+ }\n */\nfunction parseInputFieldsDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R) : [];\n}\n\n/**\n * TypeExtension :\n *   - ScalarTypeExtension\n *   - ObjectTypeExtension\n *   - InterfaceTypeExtension\n *   - UnionTypeExtension\n *   - EnumTypeExtension\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeExtension(lexer) {\n  var keywordToken = lexer.lookahead();\n\n  if (keywordToken.kind === _lexer.TokenKind.NAME) {\n    switch (keywordToken.value) {\n      case 'scalar':\n        return parseScalarTypeExtension(lexer);\n      case 'type':\n        return parseObjectTypeExtension(lexer);\n      case 'interface':\n        return parseInterfaceTypeExtension(lexer);\n      case 'union':\n        return parseUnionTypeExtension(lexer);\n      case 'enum':\n        return parseEnumTypeExtension(lexer);\n      case 'input':\n        return parseInputObjectTypeExtension(lexer);\n    }\n  }\n\n  throw unexpected(lexer, keywordToken);\n}\n\n/**\n * ScalarTypeExtension :\n *   - extend scalar Name Directives[Const]\n */\nfunction parseScalarTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  if (directives.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.SCALAR_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectTypeExtension :\n *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n *  - extend type Name ImplementsInterfaces? Directives[Const]\n *  - extend type Name ImplementsInterfaces\n */\nfunction parseObjectTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.OBJECT_TYPE_EXTENSION,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InterfaceTypeExtension :\n *   - extend interface Name Directives[Const]? FieldsDefinition\n *   - extend interface Name Directives[Const]\n */\nfunction parseInterfaceTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  if (directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.INTERFACE_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * UnionTypeExtension :\n *   - extend union Name Directives[Const]? MemberTypesDefinition\n *   - extend union Name Directives[Const]\n */\nfunction parseUnionTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var types = parseMemberTypesDefinition(lexer);\n  if (directives.length === 0 && types.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.UNION_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * EnumTypeExtension :\n *   - extend enum Name Directives[Const]? EnumValuesDefinition\n *   - extend enum Name Directives[Const]\n */\nfunction parseEnumTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var values = parseEnumValuesDefinition(lexer);\n  if (directives.length === 0 && values.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.ENUM_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * InputObjectTypeExtension :\n *   - extend input Name Directives[Const]? InputFieldsDefinition\n *   - extend input Name Directives[Const]\n */\nfunction parseInputObjectTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseInputFieldsDefinition(lexer);\n  if (directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n  return {\n    kind: _kinds.INPUT_OBJECT_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveDefinition :\n *   - Description? directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\nfunction parseDirectiveDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'directive');\n  expect(lexer, _lexer.TokenKind.AT);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  var locations = parseDirectiveLocations(lexer);\n  return {\n    kind: _kinds.DIRECTIVE_DEFINITION,\n    description: description,\n    name: name,\n    arguments: args,\n    locations: locations,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveLocations :\n *   - `|`? DirectiveLocation\n *   - DirectiveLocations | DirectiveLocation\n */\nfunction parseDirectiveLocations(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var locations = [];\n  do {\n    locations.push(parseDirectiveLocation(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n  return locations;\n}\n\n/*\n * DirectiveLocation :\n *   - ExecutableDirectiveLocation\n *   - TypeSystemDirectiveLocation\n *\n * ExecutableDirectiveLocation : one of\n *   `QUERY`\n *   `MUTATION`\n *   `SUBSCRIPTION`\n *   `FIELD`\n *   `FRAGMENT_DEFINITION`\n *   `FRAGMENT_SPREAD`\n *   `INLINE_FRAGMENT`\n *\n * TypeSystemDirectiveLocation : one of\n *   `SCHEMA`\n *   `SCALAR`\n *   `OBJECT`\n *   `FIELD_DEFINITION`\n *   `ARGUMENT_DEFINITION`\n *   `INTERFACE`\n *   `UNION`\n *   `ENUM`\n *   `ENUM_VALUE`\n *   `INPUT_OBJECT`\n *   `INPUT_FIELD_DEFINITION`\n */\nfunction parseDirectiveLocation(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n  if (_directiveLocation.DirectiveLocation.hasOwnProperty(name.value)) {\n    return name;\n  }\n  throw unexpected(lexer, start);\n}\n\n// Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\nfunction loc(lexer, startToken) {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return { start: this.start, end: this.end };\n};\n\n/**\n * Determines if the next token is of a given kind\n */\nfunction peek(lexer, kind) {\n  return lexer.token.kind === kind;\n}\n\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\nfunction skip(lexer, kind) {\n  var match = lexer.token.kind === kind;\n  if (match) {\n    lexer.advance();\n  }\n  return match;\n}\n\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\nfunction expect(lexer, kind) {\n  var token = lexer.token;\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected ' + kind + ', found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\nfunction expectKeyword(lexer, value) {\n  var token = lexer.token;\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n  throw (0, _error.syntaxError)(lexer.source, token.start, 'Expected \"' + value + '\", found ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\nfunction unexpected(lexer, atToken) {\n  var token = atToken || lexer.token;\n  return (0, _error.syntaxError)(lexer.source, token.start, 'Unexpected ' + (0, _lexer.getTokenDesc)(token));\n}\n\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction any(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}\n\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction many(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [parseFn(lexer)];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visit = visit;\nexports.visitInParallel = visitInParallel;\nexports.visitWithTypeInfo = visitWithTypeInfo;\nexports.getVisitFn = getVisitFn;\n\n\n/**\n * A visitor is comprised of visit functions, which are called on each node\n * during the visitor's traversal.\n */\n\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar QueryDocumentKeys = exports.QueryDocumentKeys = {\n  Name: [],\n\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name',\n  // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n\n  Directive: ['name', 'arguments'],\n\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields'],\n\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations']\n};\n\n/**\n * A KeyMap describes each the traversable properties of each kind of node.\n */\nvar BREAK = exports.BREAK = {};\n\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\nfunction visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n          node = clone;\n        }\n        var editOffset = 0;\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n          if (inArray) {\n            editKey -= editOffset;\n          }\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n      if (node === null || node === undefined) {\n        continue;\n      }\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + JSON.stringify(node));\n      }\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = { inArray: inArray, index: index, keys: keys, edits: edits, prev: stack };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\nfunction visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */false);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */true);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */false);\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n        if (result !== undefined) {\n          typeInfo.leave(node);\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind, /* isLeaving */true);\n      var result = void 0;\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\nfunction getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      var specificKindVisitor = specificVisitor[kind];\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.print = print;\n\nvar _visitor = require('./visitor');\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction print(ast) {\n  return (0, _visitor.visit)(ast, { leave: printDocASTReducer });\n} /**\n   * Copyright (c) 2015-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n\n  // Document\n\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet;\n    // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n\n\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue;\n    return variable + ': ' + type + wrap(' = ', defaultValue);\n  },\n\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n\n  // Fragments\n\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (\n      // Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      'fragment ' + name + wrap('(', join(variableDefinitions, ', '), ')') + ' ' + ('on ' + typeCondition + ' ' + wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n\n  // Value\n\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return JSON.stringify(value);\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n\n  // Directive\n\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n\n  // Type\n\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n\n  // Type System Definitions\n\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n\n  ScalarTypeDefinition: function ScalarTypeDefinition(_ref22) {\n    var description = _ref22.description,\n        name = _ref22.name,\n        directives = _ref22.directives;\n    return join([description, join(['scalar', name, join(directives, ' ')], ' ')], '\\n');\n  },\n\n  ObjectTypeDefinition: function ObjectTypeDefinition(_ref23) {\n    var description = _ref23.description,\n        name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join([description, join(['type', name, wrap('implements ', join(interfaces, ', ')), join(directives, ' '), block(fields)], ' ')], '\\n');\n  },\n\n  FieldDefinition: function FieldDefinition(_ref24) {\n    var description = _ref24.description,\n        name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return join([description, name + wrap('(', join(args, ', '), ')') + ': ' + type + wrap(' ', join(directives, ' '))], '\\n');\n  },\n\n  InputValueDefinition: function InputValueDefinition(_ref25) {\n    var description = _ref25.description,\n        name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([description, join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ')], '\\n');\n  },\n\n  InterfaceTypeDefinition: function InterfaceTypeDefinition(_ref26) {\n    var description = _ref26.description,\n        name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join([description, join(['interface', name, join(directives, ' '), block(fields)], ' ')], '\\n');\n  },\n\n  UnionTypeDefinition: function UnionTypeDefinition(_ref27) {\n    var description = _ref27.description,\n        name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join([description, join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ')], '\\n');\n  },\n\n  EnumTypeDefinition: function EnumTypeDefinition(_ref28) {\n    var description = _ref28.description,\n        name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join([description, join(['enum', name, join(directives, ' '), block(values)], ' ')], '\\n');\n  },\n\n  EnumValueDefinition: function EnumValueDefinition(_ref29) {\n    var description = _ref29.description,\n        name = _ref29.name,\n        directives = _ref29.directives;\n    return join([description, join([name, join(directives, ' ')], ' ')], '\\n');\n  },\n\n  InputObjectTypeDefinition: function InputObjectTypeDefinition(_ref30) {\n    var description = _ref30.description,\n        name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join([description, join(['input', name, join(directives, ' '), block(fields)], ' ')], '\\n');\n  },\n\n  ScalarTypeExtension: function ScalarTypeExtension(_ref31) {\n    var name = _ref31.name,\n        directives = _ref31.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n\n  ObjectTypeExtension: function ObjectTypeExtension(_ref32) {\n    var name = _ref32.name,\n        interfaces = _ref32.interfaces,\n        directives = _ref32.directives,\n        fields = _ref32.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ', ')), join(directives, ' '), block(fields)], ' ');\n  },\n\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives,\n        fields = _ref33.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n\n  UnionTypeExtension: function UnionTypeExtension(_ref34) {\n    var name = _ref34.name,\n        directives = _ref34.directives,\n        types = _ref34.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n\n  EnumTypeExtension: function EnumTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        values = _ref35.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        fields = _ref36.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  },\n\n  DirectiveDefinition: function DirectiveDefinition(_ref37) {\n    var description = _ref37.description,\n        name = _ref37.name,\n        args = _ref37.arguments,\n        locations = _ref37.locations;\n    return join([description, 'directive @' + name + wrap('(', join(args, ', '), ')') + ' on ' + join(locations, ' | ')], '\\n');\n  }\n};\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n  return array && array.length !== 0 ? indent('{\\n' + join(array, '\\n')) + '\\n}' : '';\n}\n\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && maybeString.replace(/\\n/g, '\\n  ');\n}\n\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription) {\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? '\"\"\"' + value.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"' : isDescription ? '\"\"\"\\n' + value.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"' : indent('\"\"\"\\n' + value.replace(/\"\"\"/g, '\\\\\"\"\"')) + '\\n\"\"\"';\n}","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n","import { parse } from \"graphql/language/parser\";\nimport { print } from \"graphql/language/printer\";\n\n// @ts-ignore\nimport lodashIsEqual from \"lodash.isequal\";\n\n/**\n * Capitalizes the first letter of the given string.\n *\n * @param {string} input\n * @returns {string}\n */\nexport function upcaseFirstLetter(input: string) {\n  return input.charAt(0).toUpperCase() + input.slice(1);\n}\n\n/**\n * Down cases the first letter of the given string.\n *\n * @param {string} input\n * @returns {string}\n */\nexport function downcaseFirstLetter(input: string) {\n  return input.charAt(0).toLowerCase() + input.slice(1);\n}\n\n/**\n * Takes a string with a graphql query and formats it. Useful for debug output and the tests.\n * @param {string} query\n * @returns {string}\n */\nexport function prettify(query: string): string {\n  return print(parse(query));\n}\n\n/**\n * Tells if a object is just a simple object.\n *\n * @param {any} value - Value to check.\n */\nexport function isPlainObject(value: any): boolean {\n  return (\n    value != null && typeof value === \"object\" && Object.getPrototypeOf(value) === Object.prototype\n  );\n}\n\n/**\n * Creates an object composed of the picked `object` properties.\n * @param {object} object - Object.\n * @param {array} props - Properties to pick.\n */\nexport function pick(object: any, props: Array<string>) {\n  if (!object) {\n    return {};\n  }\n\n  let index = -1;\n  const length = props.length;\n  const result = {};\n\n  while (++index < length) {\n    const prop = props[index];\n    result[prop] = object[prop];\n  }\n\n  return result;\n}\n\nexport function isEqual(a: object, b: object): boolean {\n  // Couldn' find a simpler working implementation yet.\n  return lodashIsEqual(a, b);\n}\n\nexport function clone(input: any): any {\n  return JSON.parse(JSON.stringify(input));\n}\n\nexport function takeWhile(\n  array: Array<any>,\n  predicate: (x: any, idx: number, array: Array<any>) => any\n) {\n  let index = -1;\n\n  while (++index < array.length && predicate(array[index], index, array)) {\n    // just increase index\n  }\n\n  return array.slice(0, index);\n}\n\nexport function matches(source: any) {\n  source = clone(source);\n\n  return (object: any) => isEqual(object, source);\n}\n","import { DocumentNode } from \"graphql\";\nimport { Arguments } from \"../support/interfaces\";\nimport { FetchPolicy } from \"apollo-client\";\nimport { isPlainObject, prettify } from \"../support/utils\";\n\n/**\n * Vuex-ORM-Apollo Debug Logger.\n * Wraps console and only logs if enabled.\n *\n * Also contains some methods to format graphql queries for the output\n */\nexport default class Logger {\n  /**\n   * Tells if any logging should happen\n   * @type {boolean}\n   */\n  private readonly enabled: boolean;\n\n  /**\n   * Fancy Vuex-ORM-Apollo prefix for all log messages.\n   * @type {string[]}\n   */\n  private readonly PREFIX = [\n    \"%c Vuex-ORM: GraphQL Plugin %c\",\n    \"background: #35495e; padding: 1px 0; border-radius: 3px; color: #eee;\",\n    \"background: transparent;\"\n  ];\n\n  /**\n   * @constructor\n   * @param {boolean} enabled Tells if any logging should happen\n   */\n  public constructor(enabled: boolean) {\n    this.enabled = enabled;\n    this.log(\"Logging is enabled.\");\n  }\n\n  /**\n   * Wraps console.group. In TEST env console.log is used instead because console.group doesn't work on CLI.\n   * If available console.groupCollapsed will be used instead.\n   * @param {Array<any>} messages\n   */\n  public group(...messages: Array<any>): void {\n    if (this.enabled) {\n      if (console.groupCollapsed) {\n        console.groupCollapsed(...this.PREFIX, ...messages);\n      } else {\n        console.log(...this.PREFIX, ...messages);\n      }\n    }\n  }\n\n  /**\n   * Wrapper for console.groupEnd. In TEST env nothing happens because console.groupEnd doesn't work on CLI.\n   */\n  public groupEnd(): void {\n    if (this.enabled && console.groupEnd) console.groupEnd();\n  }\n\n  /**\n   * Wrapper for console.log.\n   * @param {Array<any>} messages\n   */\n  public log(...messages: Array<any>): void {\n    if (this.enabled) {\n      console.log(...this.PREFIX, ...messages);\n    }\n  }\n\n  /**\n   * Wrapper for console.warn.\n   * @param {Array<any>} messages\n   */\n  public warn(...messages: Array<any>): void {\n    if (this.enabled) {\n      console.warn(...this.PREFIX, ...messages);\n    }\n  }\n\n  /**\n   * Logs a graphql query in a readable format and with all information like fetch policy and variables.\n   * @param {string | DocumentNode} query\n   * @param {Arguments} variables\n   * @param {FetchPolicy} fetchPolicy\n   */\n  public logQuery(query: string | DocumentNode, variables?: Arguments, fetchPolicy?: FetchPolicy) {\n    if (this.enabled) {\n      try {\n        let prettified = \"\";\n        if (isPlainObject(query) && (query as DocumentNode).loc) {\n          prettified = prettify((query as DocumentNode).loc!.source.body);\n        } else {\n          prettified = prettify(query as string);\n        }\n\n        this.group(\n          \"Sending query:\",\n          prettified\n            .split(\"\\n\")[1]\n            .replace(\"{\", \"\")\n            .trim()\n        );\n        console.log(prettified);\n\n        if (variables) console.log(\"VARIABLES:\", variables);\n        if (fetchPolicy) console.log(\"FETCH POLICY:\", fetchPolicy);\n\n        this.groupEnd();\n      } catch (e) {\n        console.error(\"[Vuex-ORM-Apollo] There is a syntax error in the query!\", e, query);\n      }\n    }\n  }\n}\n","import { Model as ORMModel } from \"@vuex-orm/core\";\nimport { Field } from \"../support/interfaces\";\nimport Context from \"../common/context\";\nimport { Mock, MockOptions } from \"../test-utils\";\nimport { pick, isEqual } from \"../support/utils\";\nconst inflection = require(\"inflection\");\n\n/**\n * Wrapper around a Vuex-ORM model with some useful methods.\n *\n * Also provides a mock system, to define mocking responses for actions.\n */\nexport default class Model {\n  /**\n   * The singular name of a model like `blogPost`\n   * @type {string}\n   */\n  public readonly singularName: string;\n\n  /**\n   * The plural name of a model like `blogPosts`\n   * @type {string}\n   */\n  public readonly pluralName: string;\n\n  /**\n   * The original Vuex-ORM model\n   */\n  public readonly baseModel: ORMModel;\n\n  /**\n   * The fields of the model\n   * @type {Map<string, Field>}\n   */\n  public readonly fields: Map<string, Field> = new Map<string, Field>();\n\n  /**\n   * Container for the mocks.\n   * @type {Object}\n   */\n  private mocks: { [key: string]: Array<Mock> } = {};\n\n  /**\n   * @constructor\n   * @param {Model} baseModel The original Vuex-ORM model\n   */\n  public constructor(baseModel: ORMModel) {\n    this.baseModel = baseModel;\n\n    // Generate name variants\n    this.singularName = inflection.singularize(this.baseModel.entity);\n    this.pluralName = inflection.pluralize(this.baseModel.entity);\n\n    // Cache the fields of the model in this.fields\n    const fields = this.baseModel.fields();\n    Object.keys(fields).forEach((name: string) => {\n      this.fields.set(name, fields[name]);\n    });\n  }\n\n  /**\n   * Tells if a field is a numeric field.\n   *\n   * @param {Field | undefined} field\n   * @returns {boolean}\n   */\n  public static isFieldNumber(field: Field | undefined): boolean {\n    if (!field) return false;\n\n    const context = Context.getInstance();\n    return (\n      field instanceof context.components.Number || field instanceof context.components.Increment\n    );\n  }\n\n  /**\n   * Tells if a field is a attribute (and thus not a relation)\n   * @param {Field} field\n   * @returns {boolean}\n   */\n  public static isFieldAttribute(field: Field): boolean {\n    const context = Context.getInstance();\n\n    return (\n      field instanceof context.components.Increment ||\n      field instanceof context.components.Attr ||\n      field instanceof context.components.String ||\n      field instanceof context.components.Number ||\n      field instanceof context.components.Boolean\n    );\n  }\n\n  /**\n   * Tells if a field which represents a relation is a connection (multiple).\n   * @param {Field} field\n   * @returns {boolean}\n   */\n  public static isConnection(field: Field): boolean {\n    const context = Context.getInstance();\n\n    return !(\n      field instanceof context.components.BelongsTo ||\n      field instanceof context.components.HasOne ||\n      field instanceof context.components.MorphTo ||\n      field instanceof context.components.MorphOne\n    );\n  }\n\n  /**\n   * Adds $isPersisted and other meta fields to the model by overwriting the fields() method.\n   * @todo is this a good way to add fields?\n   * @param {Model} model\n   */\n  public static augment(model: Model) {\n    const originalFieldGenerator = model.baseModel.fields.bind(model.baseModel);\n\n    model.baseModel.fields = () => {\n      const originalFields = originalFieldGenerator();\n\n      originalFields[\"$isPersisted\"] = model.baseModel.boolean(false);\n\n      return originalFields;\n    };\n  }\n\n  /**\n   * Returns all fields which should be included in a graphql query: All attributes which are not included in the\n   * skipFields array or start with $.\n   * @returns {Array<string>} field names which should be queried\n   */\n  public getQueryFields(): Array<string> {\n    const fields: Array<string> = [];\n\n    this.fields.forEach((field: Field, name: string) => {\n      if (Model.isFieldAttribute(field) && !this.skipField(name)) {\n        fields.push(name);\n      }\n    });\n\n    return fields;\n  }\n\n  /**\n   * Tells if a field should be ignored. This is true for fields that start with a `$` or is it is within the skipField\n   * property or is the foreignKey of a belongsTo/hasOne relation.\n   *\n   * @param {string} field\n   * @returns {boolean}\n   */\n  public skipField(field: string) {\n    if (field.startsWith(\"$\")) return true;\n    if (this.baseModel.skipFields && this.baseModel.skipFields.indexOf(field) >= 0) return true;\n\n    const context = Context.getInstance();\n\n    let shouldSkipField: boolean = false;\n\n    this.getRelations().forEach((relation: Field) => {\n      if (\n        (relation instanceof context.components.BelongsTo ||\n          relation instanceof context.components.HasOne) &&\n        relation.foreignKey === field\n      ) {\n        shouldSkipField = true;\n        return false;\n      }\n      return true;\n    });\n\n    return shouldSkipField;\n  }\n\n  /**\n   * @returns {Map<string, Field>} all relations of the model which should be included in a graphql query\n   */\n  public getRelations(): Map<string, Field> {\n    const relations = new Map<string, Field>();\n\n    this.fields.forEach((field: Field, name: string) => {\n      if (!Model.isFieldAttribute(field)) {\n        relations.set(name, field);\n      }\n    });\n\n    return relations;\n  }\n\n  /**\n   * This accepts a field like `subjectType` and checks if this is just randomly named `...Type` or it is part\n   * of a polymorphic relation.\n   * @param {string} name\n   * @returns {boolean}\n   */\n  public isTypeFieldOfPolymorphicRelation(name: string): boolean {\n    const context = Context.getInstance();\n    let found: boolean = false;\n\n    context.models.forEach(model => {\n      if (found) return false;\n\n      model.getRelations().forEach(relation => {\n        if (\n          relation instanceof context.components.MorphMany ||\n          relation instanceof context.components.MorphedByMany ||\n          relation instanceof context.components.MorphOne ||\n          relation instanceof context.components.MorphTo ||\n          relation instanceof context.components.MorphToMany\n        ) {\n          if (\n            relation.type === name &&\n            relation.related &&\n            relation.related.entity === this.baseModel.entity\n          ) {\n            found = true;\n            return false;\n          }\n        }\n\n        return true;\n      });\n\n      return true;\n    });\n\n    return found;\n  }\n\n  /**\n   * Returns a record of this model with the given ID.\n   * @param {number} id\n   * @returns {any}\n   */\n  public getRecordWithId(id: number) {\n    return this.baseModel\n      .query()\n      .withAllRecursive()\n      .where(\"id\", id)\n      .first();\n  }\n\n  /**\n   * Determines if we should eager load (means: add as a field in the graphql query) a related entity. belongsTo or\n   * hasOne related entities are always eager loaded. Others can be added to the `eagerLoad` array of the model.\n   *\n   * @param {string} fieldName Name of the field\n   * @param {Field} field Relation field\n   * @param {Model} relatedModel Related model\n   * @returns {boolean}\n   */\n  public shouldEagerLoadRelation(fieldName: string, field: Field, relatedModel: Model): boolean {\n    const context = Context.getInstance();\n\n    if (\n      field instanceof context.components.HasOne ||\n      field instanceof context.components.BelongsTo ||\n      field instanceof context.components.MorphOne\n    ) {\n      return true;\n    }\n\n    const eagerLoadList: Array<String> = this.baseModel.eagerLoad || [];\n    return (\n      eagerLoadList.find(n => {\n        return n === relatedModel.singularName || n === relatedModel.pluralName || n === fieldName;\n      }) !== undefined\n    );\n  }\n\n  /**\n   * Adds a mock.\n   *\n   * @param {Mock} mock - Mock config.\n   * @returns {boolean}\n   */\n  public $addMock(mock: Mock): boolean {\n    if (this.$findMock(mock.action, mock.options)) return false;\n    if (!this.mocks[mock.action]) this.mocks[mock.action] = [];\n\n    this.mocks[mock.action].push(mock);\n    return true;\n  }\n\n  /**\n   * Finds a mock for the given action and options.\n   *\n   * @param {string} action - Name of the action like 'fetch'.\n   * @param {MockOptions} options - MockOptions like { variables: { id: 42 } }.\n   * @returns {Mock | null} null when no mock was found.\n   */\n  public $findMock(action: string, options: MockOptions | undefined): Mock | null {\n    if (this.mocks[action]) {\n      return (\n        this.mocks[action].find(m => {\n          if (!m.options || !options) return true;\n\n          const relevantOptions = pick(options, Object.keys(m.options));\n          return isEqual(relevantOptions, m.options || {});\n        }) || null\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Hook to be called by all actions in order to get the mock returnValue.\n   *\n   * @param {string} action - Name of the action like 'fetch'.\n   * @param {MockOptions} options - MockOptions.\n   * @returns {any} null when no mock was found.\n   */\n  public $mockHook(action: string, options: MockOptions): any {\n    let returnValue: null | { [key: string]: any } = null;\n    const mock = this.$findMock(action, options);\n\n    if (mock) {\n      if (mock.returnValue instanceof Function) {\n        returnValue = mock.returnValue();\n      } else {\n        returnValue = mock.returnValue || null;\n      }\n    }\n\n    if (returnValue) {\n      if (returnValue instanceof Array) {\n        returnValue.forEach(r => (r.$isPersisted = true));\n      } else {\n        returnValue.$isPersisted = true;\n      }\n\n      return { [this.pluralName]: returnValue };\n    }\n\n    return null;\n  }\n}\n","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n","import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\n\nexport interface IdValue {\n  type: 'id';\n  id: string;\n  generated: boolean;\n  typename: string | undefined;\n}\n\nexport interface JsonValue {\n  type: 'json';\n  json: any;\n}\n\nexport type ListValue = Array<null | IdValue>;\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | IdValue\n  | ListValue\n  | JsonValue\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport type ScalarValue = StringValueNode | BooleanValueNode | EnumValueNode;\n\nexport function isScalarValue(value: ValueNode): value is ScalarValue {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nexport type NumberValue = IntValueNode | FloatValueNode;\n\nexport function isNumberValue(value: ValueNode): value is NumberValue {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new Error(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Object,\n  directives?: Directives,\n): string {\n  if (\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const queryArgs = args as { [key: string]: any };\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = queryArgs[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables: Object,\n): Object {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport function isIdValue(idObject: StoreValue): idObject is IdValue {\n  return idObject && (idObject as IdValue | JsonValue).type === 'id';\n}\n\nexport type IdConfig = {\n  id: string;\n  typename: string | undefined;\n};\n\nexport function toIdValue(\n  idConfig: string | IdConfig,\n  generated = false,\n): IdValue {\n  return {\n    type: 'id',\n    generated,\n    ...(typeof idConfig === 'string'\n      ? { id: idConfig, typename: undefined }\n      : idConfig),\n  };\n}\n\nexport function isJsonValue(jsonObject: StoreValue): jsonObject is JsonValue {\n  return (\n    jsonObject != null &&\n    typeof jsonObject === 'object' &&\n    (jsonObject as IdValue | JsonValue).type === 'json'\n  );\n}\n\nfunction defaultValueFromVariable(node: VariableNode) {\n  throw new Error(`Variable nodes are not supported by valueFromNode`);\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n\n/**\n * Evaluate a ValueNode and yield its value in its natural JS form.\n */\nexport function valueFromNode(\n  node: ValueNode,\n  onVariable: VariableValue = defaultValueFromVariable,\n): any {\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'ListValue':\n      return node.values.map(v => valueFromNode(v, onVariable));\n    case 'ObjectValue': {\n      const value: { [key: string]: any } = {};\n      for (const field of node.fields) {\n        value[field.name.value] = valueFromNode(field.value, onVariable);\n      }\n      return value;\n    }\n    default:\n      return node.value;\n  }\n}\n","// Provides the methods that allow QueryManager to handle\r\n// the `skip` and `include` directives within GraphQL.\r\nimport {\r\n  FieldNode,\r\n  OperationDefinitionNode,\r\n  SelectionNode,\r\n  VariableNode,\r\n  BooleanValueNode,\r\n  DirectiveNode,\r\n  DocumentNode,\r\n} from 'graphql';\r\n\r\nimport { argumentsObjectFromField } from './storeUtils';\r\n\r\nexport type DirectiveInfo = {\r\n  [fieldName: string]: { [argName: string]: any };\r\n};\r\n\r\nexport function getDirectiveInfoFromField(\r\n  field: FieldNode,\r\n  variables: Object,\r\n): DirectiveInfo {\r\n  if (field.directives && field.directives.length) {\r\n    const directiveObj: DirectiveInfo = {};\r\n    field.directives.forEach((directive: DirectiveNode) => {\r\n      directiveObj[directive.name.value] = argumentsObjectFromField(\r\n        directive,\r\n        variables,\r\n      );\r\n    });\r\n    return directiveObj;\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function shouldInclude(\r\n  selection: SelectionNode,\r\n  variables: { [name: string]: any } = {},\r\n): boolean {\r\n  if (!selection.directives) {\r\n    return true;\r\n  }\r\n\r\n  let res: boolean = true;\r\n  selection.directives.forEach(directive => {\r\n    // TODO should move this validation to GraphQL validation once that's implemented.\r\n    if (directive.name.value !== 'skip' && directive.name.value !== 'include') {\r\n      // Just don't worry about directives we don't understand\r\n      return;\r\n    }\r\n\r\n    //evaluate the \"if\" argument and skip (i.e. return undefined) if it evaluates to true.\r\n    const directiveArguments = directive.arguments || [];\r\n    const directiveName = directive.name.value;\r\n    if (directiveArguments.length !== 1) {\r\n      throw new Error(\r\n        `Incorrect number of arguments for the @${directiveName} directive.`,\r\n      );\r\n    }\r\n\r\n    const ifArgument = directiveArguments[0];\r\n    if (!ifArgument.name || ifArgument.name.value !== 'if') {\r\n      throw new Error(`Invalid argument for the @${directiveName} directive.`);\r\n    }\r\n\r\n    const ifValue = directiveArguments[0].value;\r\n    let evaledValue: boolean = false;\r\n    if (!ifValue || ifValue.kind !== 'BooleanValue') {\r\n      // means it has to be a variable value if this is a valid @skip or @include directive\r\n      if (ifValue.kind !== 'Variable') {\r\n        throw new Error(\r\n          `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\r\n        );\r\n      } else {\r\n        evaledValue = variables[(ifValue as VariableNode).name.value];\r\n        if (evaledValue === undefined) {\r\n          throw new Error(\r\n            `Invalid variable referenced in @${directiveName} directive.`,\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      evaledValue = (ifValue as BooleanValueNode).value;\r\n    }\r\n\r\n    if (directiveName === 'skip') {\r\n      evaledValue = !evaledValue;\r\n    }\r\n\r\n    if (!evaledValue) {\r\n      res = false;\r\n    }\r\n  });\r\n\r\n  return res;\r\n}\r\n\r\nexport function flattenSelections(selection: SelectionNode): SelectionNode[] {\r\n  if (\r\n    !(selection as FieldNode).selectionSet ||\r\n    !((selection as FieldNode).selectionSet.selections.length > 0)\r\n  )\r\n    return [selection];\r\n\r\n  return [selection].concat(\r\n    (selection as FieldNode).selectionSet.selections\r\n      .map(selectionNode =>\r\n        [selectionNode].concat(flattenSelections(selectionNode)),\r\n      )\r\n      .reduce((selections, selected) => selections.concat(selected), []),\r\n  );\r\n}\r\n\r\nexport function getDirectiveNames(doc: DocumentNode) {\r\n  // operation => [names of directives];\r\n  const directiveNames = doc.definitions\r\n    .filter(\r\n      (definition: OperationDefinitionNode) =>\r\n        definition.selectionSet && definition.selectionSet.selections,\r\n    )\r\n    // operation => [[Selection]]\r\n    .map(x => flattenSelections(x as any))\r\n    // [[Selection]] => [Selection]\r\n    .reduce((selections, selected) => selections.concat(selected), [])\r\n    // [Selection] => [Selection with Directives]\r\n    .filter(\r\n      (selection: SelectionNode) =>\r\n        selection.directives && selection.directives.length > 0,\r\n    )\r\n    // [Selection with Directives] => [[Directives]]\r\n    .map((selection: SelectionNode) => selection.directives)\r\n    // [[Directives]] => [Directives]\r\n    .reduce((directives, directive) => directives.concat(directive), [])\r\n    // [Directives] => [Name]\r\n    .map((directive: DirectiveNode) => directive.name.value);\r\n  return directiveNames;\r\n}\r\n\r\nexport function hasDirectives(names: string[], doc: DocumentNode) {\r\n  return getDirectiveNames(doc).some(\r\n    (name: string) => names.indexOf(name) > -1,\r\n  );\r\n}\r\n","import { DocumentNode, FragmentDefinitionNode } from 'graphql';\r\n\r\n/**\r\n * Returns a query document which adds a single query operation that only\r\n * spreads the target fragment inside of it.\r\n *\r\n * So for example a document of:\r\n *\r\n * ```graphql\r\n * fragment foo on Foo { a b c }\r\n * ```\r\n *\r\n * Turns into:\r\n *\r\n * ```graphql\r\n * { ...foo }\r\n *\r\n * fragment foo on Foo { a b c }\r\n * ```\r\n *\r\n * The target fragment will either be the only fragment in the document, or a\r\n * fragment specified by the provided `fragmentName`. If there is more then one\r\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\r\n */\r\nexport function getFragmentQueryDocument(\r\n  document: DocumentNode,\r\n  fragmentName?: string,\r\n): DocumentNode {\r\n  let actualFragmentName = fragmentName;\r\n\r\n  // Build an array of all our fragment definitions that will be used for\r\n  // validations. We also do some validations on the other definitions in the\r\n  // document while building this list.\r\n  const fragments: Array<FragmentDefinitionNode> = [];\r\n  document.definitions.forEach(definition => {\r\n    // Throw an error if we encounter an operation definition because we will\r\n    // define our own operation definition later on.\r\n    if (definition.kind === 'OperationDefinition') {\r\n      throw new Error(\r\n        `Found a ${definition.operation} operation${\r\n          definition.name ? ` named '${definition.name.value}'` : ''\r\n        }. ` +\r\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\r\n      );\r\n    }\r\n    // Add our definition to the fragments array if it is a fragment\r\n    // definition.\r\n    if (definition.kind === 'FragmentDefinition') {\r\n      fragments.push(definition);\r\n    }\r\n  });\r\n\r\n  // If the user did not give us a fragment name then let us try to get a\r\n  // name from a single fragment in the definition.\r\n  if (typeof actualFragmentName === 'undefined') {\r\n    if (fragments.length !== 1) {\r\n      throw new Error(\r\n        `Found ${\r\n          fragments.length\r\n        } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\r\n      );\r\n    }\r\n    actualFragmentName = fragments[0].name.value;\r\n  }\r\n\r\n  // Generate a query document with an operation that simply spreads the\r\n  // fragment inside of it.\r\n  const query: DocumentNode = {\r\n    ...document,\r\n    definitions: [\r\n      {\r\n        kind: 'OperationDefinition',\r\n        operation: 'query',\r\n        selectionSet: {\r\n          kind: 'SelectionSet',\r\n          selections: [\r\n            {\r\n              kind: 'FragmentSpread',\r\n              name: {\r\n                kind: 'Name',\r\n                value: actualFragmentName,\r\n              },\r\n            },\r\n          ],\r\n        },\r\n      },\r\n      ...document.definitions,\r\n    ],\r\n  };\r\n\r\n  return query;\r\n}\r\n","/**\r\n * Adds the properties of one or more source objects to a target object. Works exactly like\r\n * `Object.assign`, but as a utility to maintain support for IE 11.\r\n *\r\n * @see https://github.com/apollostack/apollo-client/pull/1009\r\n */\r\nexport function assign<A, B>(a: A, b: B): A & B;\r\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\r\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\r\nexport function assign<A, B, C, D, E>(\r\n  a: A,\r\n  b: B,\r\n  c: C,\r\n  d: D,\r\n  e: E,\r\n): A & B & C & D & E;\r\nexport function assign(target: any, ...sources: Array<any>): any;\r\nexport function assign(\r\n  target: { [key: string]: any },\r\n  ...sources: Array<{ [key: string]: any }>\r\n): { [key: string]: any } {\r\n  sources.forEach(source => {\r\n    if (typeof source === 'undefined' || source === null) {\r\n      return;\r\n    }\r\n    Object.keys(source).forEach(key => {\r\n      target[key] = source[key];\r\n    });\r\n  });\r\n  return target;\r\n}\r\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\nimport { assign } from './util/assign';\n\nimport { valueToObjectRepresentation, JsonValue } from './storeUtils';\n\nexport function getMutationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode {\n  checkDocument(doc);\n\n  let mutationDef: OperationDefinitionNode | null = doc.definitions.filter(\n    definition =>\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'mutation',\n  )[0] as OperationDefinitionNode;\n\n  if (!mutationDef) {\n    throw new Error('Must contain a mutation definition.');\n  }\n\n  return mutationDef;\n}\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  if (doc.kind !== 'Document') {\n    throw new Error(`Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`);\n  }\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new Error(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  if (operations.length > 1) {\n    throw new Error(\n      `Ambiguous GraphQL document: contains ${operations.length} operations`,\n    );\n  }\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationDefinitionOrDie(\n  document: DocumentNode,\n): OperationDefinitionNode {\n  const def = getOperationDefinition(document);\n  if (!def) {\n    throw new Error(`GraphQL document is missing an operation`);\n  }\n  return def;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  if (!queryDef || queryDef.operation !== 'query') {\n    throw new Error('Must contain a query definition.');\n  }\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  if (doc.kind !== 'Document') {\n    throw new Error(`Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`);\n  }\n\n  if (doc.definitions.length > 1) {\n    throw new Error('Fragment must have exactly one definition.');\n  }\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  if (fragmentDef.kind !== 'FragmentDefinition') {\n    throw new Error('Must be a fragment definition.');\n  }\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new Error(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): { [key: string]: JsonValue } {\n  if (\n    definition &&\n    definition.variableDefinitions &&\n    definition.variableDefinitions.length\n  ) {\n    const defaultValues = definition.variableDefinitions\n      .filter(({ defaultValue }) => defaultValue)\n      .map(\n        ({ variable, defaultValue }): { [key: string]: JsonValue } => {\n          const defaultValueObj: { [key: string]: JsonValue } = {};\n          valueToObjectRepresentation(\n            defaultValueObj,\n            variable.name,\n            defaultValue as ValueNode,\n          );\n\n          return defaultValueObj;\n        },\n      );\n\n    return assign({}, ...defaultValues);\n  }\n\n  return {};\n}\n\n/**\n * Returns the names of all variables declared by the operation.\n */\nexport function variablesInOperation(\n  operation: OperationDefinitionNode,\n): Set<string> {\n  const names = new Set<string>();\n  if (operation.variableDefinitions) {\n    for (const definition of operation.variableDefinitions) {\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define('fclone', [], factory);\n    } else if (typeof module === 'object' && module.exports) {\n\t\t\t  //node\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.fclone = factory();\n    }\n}(this, function () {\n  'use strict';\n\n// see if it looks and smells like an iterable object, and do accept length === 0\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction isArrayLike(item) {\n  if (Array.isArray(item)) return true;\n\n  var len = item && item.length;\n  return typeof len === 'number' && (len === 0 || len - 1 in item) && typeof item.indexOf === 'function';\n}\n\nfunction fclone(obj, refs) {\n  if (!obj || \"object\" !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;\n\n  if (obj instanceof Date) {\n    return new Date(obj);\n  }\n\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {\n    return new Buffer(obj);\n  }\n\n  // typed array Int32Array etc.\n  if (typeof obj.subarray === 'function' && /[A-Z][A-Za-z\\d]+Array/.test(Object.prototype.toString.call(obj))) {\n    return obj.subarray(0);\n  }\n\n  if (!refs) {\n    refs = [];\n  }\n\n  if (isArrayLike(obj)) {\n    refs[refs.length] = obj;\n    var _l = obj.length;\n    var i = -1;\n    var _copy = [];\n\n    while (_l > ++i) {\n      _copy[i] = ~refs.indexOf(obj[i]) ? '[Circular]' : fclone(obj[i], refs);\n    }\n\n    refs.length && refs.length--;\n    return _copy;\n  }\n\n  refs[refs.length] = obj;\n  var copy = {};\n\n  if (obj instanceof Error) {\n    copy.name = obj.name;\n    copy.message = obj.message;\n    copy.stack = obj.stack;\n  }\n\n  var keys = Object.keys(obj);\n  var l = keys.length;\n\n  while (l--) {\n    var k = keys[l];\n    copy[k] = ~refs.indexOf(obj[k]) ? '[Circular]' : fclone(obj[k], refs);\n  }\n\n  refs.length && refs.length--;\n  return copy;\n}\n\nfclone.default = fclone;\n  return fclone\n}));","import fclone from 'fclone';\r\n\r\n/**\r\n * Deeply clones a value to create a new instance.\r\n */\r\nexport function cloneDeep<T>(value: T): T {\r\n  return fclone(value);\r\n}\r\n","import {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  DefinitionNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nimport { cloneDeep } from './util/cloneDeep';\n\nimport {\n  checkDocument,\n  getOperationDefinitionOrDie,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n} from './getFromAST';\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename',\n  },\n};\n\nfunction isNotEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): Boolean {\n  // keep selections that are still valid\n  return (\n    op.selectionSet.selections.filter(\n      selectionSet =>\n        // anything that doesn't match the compound filter is okay\n        !// not an empty array\n        (\n          selectionSet &&\n          // look into fragments to verify they should stay\n          selectionSet.kind === 'FragmentSpread' &&\n          // see if the fragment in the map is valid (recursively)\n          !isNotEmpty(fragments[selectionSet.name.value], fragments)\n        ),\n    ).length > 0\n  );\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode): Boolean {\n    return directives.some(\n      (dir: RemoveDirectiveConfig | GetDirectiveConfig) => {\n        if (dir.name && dir.name === directive.name.value) return true;\n        if (dir.test && dir.test(directive)) return true;\n        return false;\n      },\n    );\n  };\n}\n\nfunction addTypenameToSelectionSet(\n  selectionSet: SelectionSetNode,\n  isRoot = false,\n) {\n  if (selectionSet.selections) {\n    if (!isRoot) {\n      const alreadyHasThisField = selectionSet.selections.some(selection => {\n        return (\n          selection.kind === 'Field' &&\n          (selection as FieldNode).name.value === '__typename'\n        );\n      });\n\n      if (!alreadyHasThisField) {\n        selectionSet.selections.push(TYPENAME_FIELD);\n      }\n    }\n\n    selectionSet.selections.forEach(selection => {\n      // Must not add __typename if we're inside an introspection query\n      if (selection.kind === 'Field') {\n        if (\n          selection.name.value.lastIndexOf('__', 0) !== 0 &&\n          selection.selectionSet\n        ) {\n          addTypenameToSelectionSet(selection.selectionSet);\n        }\n      } else if (selection.kind === 'InlineFragment') {\n        if (selection.selectionSet) {\n          addTypenameToSelectionSet(selection.selectionSet);\n        }\n      }\n    });\n  }\n}\n\nexport type RemoveDirectiveConfig = {\n  name?: string;\n  test?: (directive: DirectiveNode) => boolean;\n  remove?: boolean;\n};\n\nfunction removeDirectivesFromSelectionSet(\n  directives: RemoveDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n): SelectionSetNode {\n  if (!selectionSet.selections) return selectionSet;\n  // if any of the directives are set to remove this selectionSet, remove it\n  const agressiveRemove = directives.some(\n    (dir: RemoveDirectiveConfig) => dir.remove,\n  );\n\n  selectionSet.selections = selectionSet.selections\n    .map(selection => {\n      if (\n        selection.kind !== 'Field' ||\n        !(selection as FieldNode) ||\n        !selection.directives\n      )\n        return selection;\n      const directiveMatcher = getDirectiveMatcher(directives);\n      let remove: boolean;\n      selection.directives = selection.directives.filter(directive => {\n        const shouldKeep = !directiveMatcher(directive);\n\n        if (!remove && !shouldKeep && agressiveRemove) remove = true;\n\n        return shouldKeep;\n      });\n\n      return remove ? null : selection;\n    })\n    .filter(x => !!x);\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (selection.kind === 'Field' || selection.kind === 'InlineFragment') &&\n      selection.selectionSet\n    ) {\n      removeDirectivesFromSelectionSet(directives, selection.selectionSet);\n    }\n  });\n\n  return selectionSet;\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const docClone = cloneDeep(doc);\n\n  docClone.definitions.forEach((definition: DefinitionNode) => {\n    removeDirectivesFromSelectionSet(\n      directives,\n      (definition as OperationDefinitionNode).selectionSet,\n    );\n  });\n  const operation = getOperationDefinitionOrDie(docClone);\n  const fragments = createFragmentMap(getFragmentDefinitions(docClone));\n  return isNotEmpty(operation, fragments) ? docClone : null;\n}\n\nexport function addTypenameToDocument(doc: DocumentNode) {\n  checkDocument(doc);\n  const docClone = cloneDeep(doc);\n\n  docClone.definitions.forEach((definition: DefinitionNode) => {\n    const isRoot = definition.kind === 'OperationDefinition';\n    addTypenameToSelectionSet(\n      (definition as OperationDefinitionNode).selectionSet,\n      isRoot,\n    );\n  });\n  return docClone;\n}\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        console.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  checkDocument(doc);\n  return removeDirectivesFromDocument([connectionRemoveConfig], doc);\n}\n\nexport type GetDirectiveConfig = {\n  name?: string;\n  test?: (directive: DirectiveNode) => boolean;\n};\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n  nestedCheck = true,\n): boolean {\n  if (!(selectionSet && selectionSet.selections)) {\n    return false;\n  }\n  const matchedSelections = selectionSet.selections.filter(selection => {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n  return matchedSelections.length > 0;\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (selection.kind !== 'Field' || !(selection as FieldNode)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const matchedDirectives = selection.directives.filter(directiveMatcher);\n  return (\n    matchedDirectives.length > 0 ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nfunction getDirectivesFromSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n) {\n  selectionSet.selections = selectionSet.selections\n    .filter(selection => {\n      return hasDirectivesInSelection(directives, selection, true);\n    })\n    .map(selection => {\n      if (hasDirectivesInSelection(directives, selection, false)) {\n        return selection;\n      }\n      if (\n        (selection.kind === 'Field' || selection.kind === 'InlineFragment') &&\n        selection.selectionSet\n      ) {\n        selection.selectionSet = getDirectivesFromSelectionSet(\n          directives,\n          selection.selectionSet,\n        );\n      }\n      return selection;\n    });\n  return selectionSet;\n}\n\nexport function getDirectivesFromDocument(\n  directives: GetDirectiveConfig[],\n  doc: DocumentNode,\n  includeAllFragments = false,\n): DocumentNode | null {\n  checkDocument(doc);\n  const docClone = cloneDeep(doc);\n  docClone.definitions = docClone.definitions.map(definition => {\n    if (\n      (definition.kind === 'OperationDefinition' ||\n        (definition.kind === 'FragmentDefinition' && !includeAllFragments)) &&\n      definition.selectionSet\n    ) {\n      definition.selectionSet = getDirectivesFromSelectionSet(\n        directives,\n        definition.selectionSet,\n      );\n    }\n    return definition;\n  });\n\n  const operation = getOperationDefinitionOrDie(docClone);\n  const fragments = createFragmentMap(getFragmentDefinitions(docClone));\n  return isNotEmpty(operation, fragments) ? docClone : null;\n}\n","export function getEnv(): string | undefined {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  // default environment\n  return 'development';\n}\n\nexport function isEnv(env: string): boolean {\n  return getEnv() === env;\n}\n\nexport function isProduction(): boolean {\n  return isEnv('production') === true;\n}\n\nexport function isDevelopment(): boolean {\n  return isEnv('development') === true;\n}\n\nexport function isTest(): boolean {\n  return isEnv('test') === true;\n}\n","import { ExecutionResult } from 'graphql';\n\nexport function tryFunctionOrLogError(f: Function) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nexport function graphQLResultHasError(result: ExecutionResult) {\n  return result.errors && result.errors.length;\n}\n","/**\n * Performs a deep equality check on two JavaScript values.\n */\nexport function isEqual(a: any, b: any): boolean {\n  // If the two values are strictly equal, we are good.\n  if (a === b) {\n    return true;\n  }\n  // Dates are equivalent if their time values are equal.\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  // If a and b are both objects, we will compare their properties. This will compare arrays as\n  // well.\n  if (\n    a != null &&\n    typeof a === 'object' &&\n    b != null &&\n    typeof b === 'object'\n  ) {\n    // Compare all of the keys in `a`. If one of the keys has a different value, or that key does\n    // not exist in `b` return false immediately.\n    for (const key in a) {\n      if (Object.prototype.hasOwnProperty.call(a, key)) {\n        if (!Object.prototype.hasOwnProperty.call(b, key)) {\n          return false;\n        }\n        if (!isEqual(a[key], b[key])) {\n          return false;\n        }\n      }\n    }\n    // Look through all the keys in `b`. If `b` has a key that `a` does not, return false.\n    for (const key in b) {\n      if (!Object.prototype.hasOwnProperty.call(a, key)) {\n        return false;\n      }\n    }\n    // If we made it this far the objects are equal!\n    return true;\n  }\n  // Otherwise the values are not equal.\n  return false;\n}\n","import { isProduction, isTest } from './environment';\n\nconst haveWarned = Object.create({});\n\n/**\n * Print a warning only once in development.\n * In production no warnings are printed.\n * In test all warnings are printed.\n *\n * @param msg The warning message\n * @param type warn or error (will call console.warn or console.error)\n */\nexport function warnOnceInDevelopment(msg: string, type = 'warn') {\n  if (isProduction()) {\n    return;\n  }\n  if (!haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n    switch (type) {\n      case 'error':\n        console.error(msg);\n        break;\n      default:\n        console.warn(msg);\n    }\n  }\n}\n",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/core/networkStatus.ts"},"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// === Symbol Support ===\n\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\n// === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n\n  if (value == null) return undefined;\n\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[getSymbol('species')];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n  if (!queue) {\n    return;\n  }\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({ type: type, value: value });\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{ type: type, value: value }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = function () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = function () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: 'next',\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: 'error',\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: 'complete',\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = exports.Observable = function () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: 'subscribe',\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: 'map',\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'filter',\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'reduce',\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'concat',\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscription = void 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (sources.length === 0) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources.shift()));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: 'flatMap',\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: getSymbol('observable'),\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: 'from',\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n\n      if (x == null) throw new TypeError(x + ' is not an object');\n\n      var method = getMethod(x, getSymbol('observable'));\n      if (method) {\n        var observable = method.call(x);\n\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n\n        if (isObservable(observable) && observable.constructor === C) return observable;\n\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, getSymbol('iterator'));\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var item = _step.value;\n\n                  observer.next(item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: 'of',\n    value: function of() {\n      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: getSymbol('species'),\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: getSymbol('observable'),\n      hostReportError: hostReportError\n    },\n    configurabe: true\n  });\n}","/* tslint:disable */\n\nimport zenObservable from 'zen-observable';\n\nnamespace Observable {\n\n}\n\nimport { ZenObservable } from './types';\n\nexport { ZenObservable };\n\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\nexport type ObservableLike<T> = ZenObservable.ObservableLike<T>;\n\nexport const Observable: {\n  new <T>(subscriber: Subscriber<T>): Observable<T>;\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n} = <any>zenObservable;\n\nexport interface Observable<T> {\n  subscribe(\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): ZenObservable.Subscription;\n\n  forEach(fn: (value: T) => void): Promise<void>;\n\n  map<R>(fn: (value: T) => R): Observable<R>;\n\n  filter(fn: (value: T) => boolean): Observable<T>;\n\n  reduce<R = T>(\n    fn: (previousValue: R | T, currentValue: T) => R | T,\n    initialValue?: R | T,\n  ): Observable<R | T>;\n\n  flatMap<R>(fn: (value: T) => ZenObservable.ObservableLike<R>): Observable<R>;\n\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n}\n","module.exports = require('./lib/Observable.js').Observable;\n","import { getOperationName } from 'apollo-utilities';\nimport Observable from 'zen-observable-ts';\nimport { print } from 'graphql/language/printer';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new Error(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          console.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX we're assuming here that variables will be serialized in the same order.\n  // that might not always be true\n  return `${print(operation.query)}|${JSON.stringify(operation.variables)}|${\n    operation.operationName\n  }`;\n}\n","import Observable from 'zen-observable-ts';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nconst passthrough = (op, forward) => (forward ? forward(op) : Observable.of());\n\nconst toLink = (handler: RequestHandler | ApolloLink) =>\n  typeof handler === 'function' ? new ApolloLink(handler) : handler;\n\nexport const empty = (): ApolloLink =>\n  new ApolloLink((op, forward) => Observable.of());\n\nexport const from = (links: ApolloLink[]): ApolloLink => {\n  if (links.length === 0) return empty();\n\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n};\n\nexport const split = (\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right: ApolloLink | RequestHandler = new ApolloLink(passthrough),\n): ApolloLink => {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right);\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n};\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    console.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right: ApolloLink | RequestHandler = new ApolloLink(passthrough),\n  ): ApolloLink {\n    return this.concat(split(test, left, right));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new Error('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/util/Observable.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/errors/ApolloError.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/core/types.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/core/ObservableQuery.ts"},"import {\n  ApolloLink,\n  Operation,\n  NextLink,\n  FetchResult,\n  Observable,\n} from 'apollo-link';\n\n/*\n * Expects context to contain the forceFetch field if no dedup\n */\nexport class DedupLink extends ApolloLink {\n  private inFlightRequestObservables: Map<\n    string,\n    Observable<FetchResult>\n  > = new Map();\n  private subscribers: Map<string, any> = new Map();\n\n  public request(\n    operation: Operation,\n    forward: NextLink,\n  ): Observable<FetchResult> {\n    // sometimes we might not want to deduplicate a request, for example when we want to force fetch it.\n    if (operation.getContext().forceFetch) {\n      return forward(operation);\n    }\n\n    const key = operation.toKey();\n\n    const cleanup = operationKey => {\n      this.inFlightRequestObservables.delete(operationKey);\n      const prev = this.subscribers.get(operationKey);\n      return prev;\n    };\n\n    if (!this.inFlightRequestObservables.get(key)) {\n      // this is a new request, i.e. we haven't deduplicated it yet\n      // call the next link\n      const singleObserver = forward(operation);\n      let subscription;\n\n      const sharedObserver = new Observable(observer => {\n        // this will still be called by each subscriber regardless of\n        // deduplication status\n        let prev = this.subscribers.get(key);\n        if (!prev) prev = { next: [], error: [], complete: [] };\n\n        this.subscribers.set(key, {\n          next: prev.next.concat([observer.next.bind(observer)]),\n          error: prev.error.concat([observer.error.bind(observer)]),\n          complete: prev.complete.concat([observer.complete.bind(observer)]),\n        });\n\n        if (!subscription) {\n          subscription = singleObserver.subscribe({\n            next: result => {\n              const previous = cleanup(key);\n              this.subscribers.delete(key);\n              if (previous) {\n                previous.next.forEach(next => next(result));\n                previous.complete.forEach(complete => complete());\n              }\n            },\n            error: error => {\n              const previous = cleanup(key);\n              this.subscribers.delete(key);\n              if (previous) previous.error.forEach(err => err(error));\n            },\n          });\n        }\n\n        return () => {\n          if (subscription) subscription.unsubscribe();\n          this.inFlightRequestObservables.delete(key);\n        };\n      });\n\n      this.inFlightRequestObservables.set(key, sharedObserver);\n    }\n\n    // return shared Observable\n    return this.inFlightRequestObservables.get(key);\n  }\n}\n",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/scheduler/scheduler.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/data/mutations.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/data/queries.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/core/QueryManager.ts"},{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/data/store.ts"},"exports.version = \"2.4.2\"",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/benjamin.klein/workspaces/benny/vuex-orm-graphql/node_modules/src/ApolloClient.ts"},"import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n    };\n\n    // Recurse\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    if (nestedSelSet) {\n      field.selectionSet = nestedSelSet;\n    }\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { DocumentNode } from 'graphql';\nimport { getFragmentQueryDocument } from 'apollo-utilities';\n\nimport { DataProxy, Cache } from './types';\nimport { justTypenameQuery, queryFromPojo, fragmentFromPojo } from './utils';\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  // required to implement\n  // core API\n  public abstract read<T, TVariables = any>(\n    query: Cache.ReadOptions<TVariables>,\n  ): T | null;\n  public abstract write<TResult = any, TVariables = any>(\n    write: Cache.WriteOptions<TResult, TVariables>,\n  ): void;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch(watch: Cache.WatchOptions): () => void;\n  public abstract evict<TVariables = any>(\n    query: Cache.EvictOptions<TVariables>,\n  ): Cache.EvictionResult;\n  public abstract reset(): Promise<void>;\n\n  // intializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized,\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // optimistic API\n  public abstract removeOptimistic(id: string): void;\n\n  // transactional API\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n  ): void;\n  public abstract recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    id: string,\n  ): void;\n\n  // optional API\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n  // experimental\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // DataProxy API\n  /**\n   *\n   * @param options\n   * @param optimistic\n   */\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType | null {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: Cache.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: options.query,\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: Cache.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      variables: options.variables,\n      query: getFragmentQueryDocument(options.fragment, options.fragmentName),\n    });\n  }\n\n  public writeData<TData = any>({\n    id,\n    data,\n  }: Cache.WriteDataOptions<TData>): void {\n    if (typeof id !== 'undefined') {\n      let typenameResult = null;\n      // Since we can't use fragments without having a typename in the store,\n      // we need to make sure we have one.\n      // To avoid overwriting an existing typename, we need to read it out first\n      // and generate a fake one if none exists.\n      try {\n        typenameResult = this.read({\n          rootId: id,\n          optimistic: false,\n          query: justTypenameQuery,\n        });\n      } catch (e) {\n        // Do nothing, since an error just means no typename exists\n      }\n\n      // tslint:disable-next-line\n      const __typename =\n        (typenameResult && typenameResult.__typename) || '__ClientData';\n\n      // Add a type here to satisfy the inmemory cache\n      const dataToWrite = Object.assign({ __typename }, data);\n\n      this.writeFragment({\n        id,\n        fragment: fragmentFromPojo(dataToWrite, __typename),\n        data: dataToWrite,\n      });\n    } else {\n      this.writeQuery({ query: queryFromPojo(data), data });\n    }\n  }\n}\n","import { isTest, warnOnceInDevelopment, IdValue } from 'apollo-utilities';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean {\n    const obj = context.store.get(idValue.id);\n\n    if (!obj && idValue.id === 'ROOT_QUERY') {\n      return true;\n    }\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      if (!haveWarned) {\n        console.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        console.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        console.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n\n        /* istanbul ignore if */\n        if (!isTest()) {\n          // When running tests, we want to print the warning every time\n          haveWarned = true;\n        }\n      }\n\n      context.returnPartialData = true;\n      return true;\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    // XXX here we reach an issue - we don't know if this fragment should match or not. It's either:\n    // 1. A fragment on a non-matching concrete type or interface or union\n    // 2. A fragment on a matching interface or union\n    // If it's 1, we don't want to return anything, if it's 2 we want to match. We can't tell the\n    // difference, so we warn the user, but still try to match it (backcompat).\n    warnOnceInDevelopment(\n      'You are using the simple (heuristic) fragment matcher, but your ' +\n        'queries contain union or interface types. Apollo Client will not be ' +\n        'able to accurately map fragments. To make this error go away, use ' +\n        'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n        'https://www.apollographql.com/docs/react/recipes/fragment-matching.html',\n      'error',\n    );\n\n    context.returnPartialData = true;\n    return true;\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    if (!this.isReady) {\n      // this should basically never happen in proper use.\n      throw new Error(\n        'FragmentMatcher.match() was called before FragmentMatcher.init()',\n      );\n    }\n\n    const obj = context.store.get(idValue.id);\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      throw new Error(\n        `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n          obj,\n        )}`,\n      );\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {}\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n  public get(dataId: string): StoreObject {\n    return this.data[dataId];\n  }\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n  public delete(dataId: string): void {\n    this.data[dataId] = undefined;\n  }\n  public clear(): void {\n    this.data = Object.create(null);\n  }\n  public replace(newData: NormalizedCacheObject): void {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { FragmentMatcher } from 'graphql-anywhere';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  getQueryDefinition,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { defaultNormalizedCacheFactory, ObjectCache } from './objectCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  NormalizedCacheFactory,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${print(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\n/**\n * Writes the result of a query to the store.\n *\n * @param result The result object returned for the query document.\n *\n * @param query The query document whose result we are writing to the store.\n *\n * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n *\n * @param variables A map from the name of a variable to its value. These variables can be\n * referenced by the query document.\n *\n * @param dataIdFromObject A function that returns an object identifier given a particular result\n * object. See the store documentation for details and an example of this function.\n *\n * @param fragmentMap A map from the name of a fragment to its fragment definition. These fragments\n * can be referenced within the query document.\n *\n * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n */\nexport function writeQueryToStore({\n  result,\n  query,\n  storeFactory = defaultNormalizedCacheFactory,\n  store = storeFactory(),\n  variables,\n  dataIdFromObject,\n  fragmentMap = {} as FragmentMap,\n  fragmentMatcherFunction,\n}: {\n  result: Object;\n  query: DocumentNode;\n  store?: NormalizedCache;\n  storeFactory?: NormalizedCacheFactory;\n  variables?: Object;\n  dataIdFromObject?: IdGetter;\n  fragmentMap?: FragmentMap;\n  fragmentMatcherFunction?: FragmentMatcher;\n}): NormalizedCache {\n  const queryDefinition: OperationDefinitionNode = getQueryDefinition(query);\n\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      selectionSet: queryDefinition.selectionSet,\n      context: {\n        store,\n        storeFactory,\n        processedData: {},\n        variables,\n        dataIdFromObject,\n        fragmentMap,\n        fragmentMatcherFunction,\n      },\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, query);\n  }\n}\n\nexport type WriteContext = {\n  store: NormalizedCache;\n  storeFactory: NormalizedCacheFactory;\n  processedData?: { [x: string]: FieldNode[] };\n  variables?: any;\n  dataIdFromObject?: IdGetter;\n  fragmentMap?: FragmentMap;\n  fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport function writeResultToStore({\n  dataId,\n  result,\n  document,\n  storeFactory = defaultNormalizedCacheFactory,\n  store = storeFactory(),\n  variables,\n  dataIdFromObject,\n  fragmentMatcherFunction,\n}: {\n  dataId: string;\n  result: any;\n  document: DocumentNode;\n  store?: NormalizedCache;\n  storeFactory?: NormalizedCacheFactory;\n  variables?: Object;\n  dataIdFromObject?: IdGetter;\n  fragmentMatcherFunction?: FragmentMatcher;\n}): NormalizedCache {\n  // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n  const operationDefinition = getOperationDefinition(document);\n  const selectionSet = operationDefinition.selectionSet;\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n\n  variables = assign({}, getDefaultValues(operationDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      result,\n      dataId,\n      selectionSet,\n      context: {\n        store,\n        storeFactory,\n        processedData: {},\n        variables,\n        dataIdFromObject,\n        fragmentMap,\n        fragmentMatcherFunction,\n      },\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, document);\n  }\n}\n\nexport function writeSelectionSetToStore({\n  result,\n  dataId,\n  selectionSet,\n  context,\n}: {\n  dataId: string;\n  result: any;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n}): NormalizedCache {\n  const { variables, store, fragmentMap } = context;\n\n  selectionSet.selections.forEach(selection => {\n    const included = shouldInclude(selection, variables);\n\n    if (isField(selection)) {\n      const resultFieldKey: string = resultKeyNameFromField(selection);\n      const value: any = result[resultFieldKey];\n\n      if (included) {\n        if (typeof value !== 'undefined') {\n          writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          // if this is a defered field we don't need to throw / warn\n          const isDefered =\n            selection.directives &&\n            selection.directives.length &&\n            selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n          if (!isDefered && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            if (!isProduction()) {\n              console.warn(\n                `Missing field ${resultFieldKey} in ${JSON.stringify(\n                  result,\n                  null,\n                  2,\n                ).substring(0, 100)}`,\n              );\n            }\n          }\n        }\n      }\n    } else {\n      // This is not a field, so it must be a fragment, either inline or named\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // Named fragment\n        fragment = (fragmentMap || {})[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}.`);\n        }\n      }\n\n      let matches = true;\n      if (context.fragmentMatcherFunction && fragment.typeCondition) {\n        // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n        // Right now we have to pretend that we're passing in an idValue and that there's a store\n        // on the context.\n        const idValue = toIdValue({ id: 'self', typename: undefined });\n        const fakeContext: ReadStoreContext = {\n          // NOTE: fakeContext always uses ObjectCache\n          // since this is only to ensure the return value of 'matches'\n          store: new ObjectCache({ self: result }),\n          returnPartialData: false,\n          hasMissingField: false,\n          cacheRedirects: {},\n        };\n        matches = context.fragmentMatcherFunction(\n          idValue,\n          fragment.typeCondition.name.value,\n          fakeContext,\n        );\n        if (!isProduction() && fakeContext.returnPartialData) {\n          console.error('WARNING: heuristic fragment matching going on!');\n        }\n      }\n\n      if (included && matches) {\n        writeSelectionSetToStore({\n          result,\n          selectionSet: fragment.selectionSet,\n          dataId,\n          context,\n        });\n      }\n    }\n  });\n\n  return store;\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n) {\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue)) {\n      mergeWithGenerated(value.id, realValue.id, cache);\n    }\n    cache.delete(generatedKey);\n    cache.set(realKey, { ...generated, ...real } as StoreObject);\n  });\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n\nfunction writeFieldToStore({\n  field,\n  value,\n  dataId,\n  context,\n}: {\n  field: FieldNode;\n  value: any;\n  dataId: string;\n  context: WriteContext;\n}) {\n  const { variables, dataIdFromObject, store } = context;\n\n  let storeValue: StoreValue;\n  let storeObject: StoreObject;\n\n  const storeFieldName: string = storeKeyNameFromField(field, variables);\n  // specifies if we need to merge existing keys in the store\n  let shouldMerge = false;\n  // If we merge, this will be the generatedKey\n  let generatedKey: string = '';\n\n  // If this is a scalar value...\n  if (!field.selectionSet || value === null) {\n    storeValue =\n      value != null && typeof value === 'object'\n        ? // If the scalar value is a JSON blob, we have to \"escape\" it so it can’t pretend to be\n          // an id.\n          { type: 'json', json: value }\n        : // Otherwise, just store the scalar directly in the store.\n          value;\n  } else if (Array.isArray(value)) {\n    const generatedId = `${dataId}.${storeFieldName}`;\n\n    storeValue = processArrayValue(\n      value,\n      generatedId,\n      field.selectionSet,\n      context,\n    );\n  } else {\n    // It's an object\n    let valueDataId = `${dataId}.${storeFieldName}`;\n    let generated = true;\n\n    // We only prepend the '$' if the valueDataId isn't already a generated\n    // id.\n    if (!isGeneratedId(valueDataId)) {\n      valueDataId = '$' + valueDataId;\n    }\n\n    if (dataIdFromObject) {\n      const semanticId = dataIdFromObject(value);\n\n      // We throw an error if the first character of the id is '$. This is\n      // because we use that character to designate an Apollo-generated id\n      // and we use the distinction between user-desiginated and application-provided\n      // ids when managing overwrites.\n      if (semanticId && isGeneratedId(semanticId)) {\n        throw new Error(\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n      }\n\n      if (semanticId || (typeof semanticId === 'number' && semanticId === 0)) {\n        valueDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(valueDataId, field, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: valueDataId,\n        result: value,\n        selectionSet: field.selectionSet,\n        context,\n      });\n    }\n\n    // We take the id and escape it (i.e. wrap it with an enclosing object).\n    // This allows us to distinguish IDs from normal scalars.\n    const typename = value.__typename;\n    storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n    // check if there was a generated id at the location where we're\n    // about to place this new id. If there was, we have to merge the\n    // data from that id with the data we're about to write in the store.\n    storeObject = store.get(dataId);\n    const escapedId =\n      storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n    if (escapedId !== storeValue && isIdValue(escapedId)) {\n      const hadTypename = escapedId.typename !== undefined;\n      const hasTypename = typename !== undefined;\n      const typenameChanged =\n        hadTypename && hasTypename && escapedId.typename !== typename;\n\n      // If there is already a real id in the store and the current id we\n      // are dealing with is generated, we throw an error.\n      // One exception we allow is when the typename has changed, which occurs\n      // when schema defines a union, both with and without an ID in the same place.\n      // checks if we \"lost\" the read id\n      if (generated && !escapedId.generated && !typenameChanged) {\n        throw new Error(\n          `Store error: the application attempted to write an object with no provided id` +\n            ` but the store already contains an id of ${\n              escapedId.id\n            } for this object. The selectionSet` +\n            ` that was trying to be written is:\\n` +\n            print(field),\n        );\n      }\n      // checks if we \"lost\" the typename\n      if (hadTypename && !hasTypename) {\n        throw new Error(\n          `Store error: the application attempted to write an object with no provided typename` +\n            ` but the store already contains an object with typename of ${\n              escapedId.typename\n            } for the object of id ${escapedId.id}. The selectionSet` +\n            ` that was trying to be written is:\\n` +\n            print(field),\n        );\n      }\n\n      if (escapedId.generated) {\n        generatedKey = escapedId.id;\n        // We should only merge if it's an object of the same type,\n        // otherwise we should delete the generated object\n        if (typenameChanged) {\n          // Only delete the generated object when the old object was\n          // inlined, and the new object is not. This is indicated by\n          // the old id being generated, and the new id being real.\n          if (!generated) {\n            store.delete(generatedKey);\n          }\n        } else {\n          shouldMerge = true;\n        }\n      }\n    }\n  }\n\n  const newStoreObj = {\n    ...store.get(dataId),\n    [storeFieldName]: storeValue,\n  } as StoreObject;\n\n  if (shouldMerge) {\n    mergeWithGenerated(generatedKey, (storeValue as IdValue).id, store);\n  }\n\n  storeObject = store.get(dataId);\n  if (!storeObject || storeValue !== storeObject[storeFieldName]) {\n    store.set(dataId, newStoreObj);\n  }\n}\n\nfunction processArrayValue(\n  value: any[],\n  generatedId: string,\n  selectionSet: SelectionSetNode,\n  context: WriteContext,\n): any[] {\n  return value.map((item: any, index: any) => {\n    if (item === null) {\n      return null;\n    }\n\n    let itemDataId = `${generatedId}.${index}`;\n\n    if (Array.isArray(item)) {\n      return processArrayValue(item, itemDataId, selectionSet, context);\n    }\n\n    let generated = true;\n\n    if (context.dataIdFromObject) {\n      const semanticId = context.dataIdFromObject(item);\n\n      if (semanticId) {\n        itemDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: itemDataId,\n        result: item,\n        selectionSet,\n        context,\n      });\n    }\n\n    return toIdValue({ id: itemDataId, typename: item.__typename }, generated);\n  });\n}\n","import {\n  DocumentNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n} from 'graphql';\n\nimport {\n  getMainDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  DirectiveInfo,\n  shouldInclude,\n  getDirectiveInfoFromField,\n  isField,\n  isInlineFragment,\n  resultKeyNameFromField,\n  argumentsObjectFromField,\n} from 'apollo-utilities';\n\nexport type Resolver = (\n  fieldName: string,\n  rootValue: any,\n  args: any,\n  context: any,\n  info: ExecInfo,\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type ResultMapper = (\n  values: { [fieldName: string]: any },\n  rootValue: any,\n) => any;\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  contextValue: any;\n  variableValues: VariableMap;\n  resultMapper: ResultMapper;\n  resolver: Resolver;\n  fragmentMatcher: FragmentMatcher;\n};\n\nexport type ExecInfo = {\n  isLeaf: boolean;\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecOptions = {\n  resultMapper?: ResultMapper;\n  fragmentMatcher?: FragmentMatcher;\n};\n\n/* Based on graphql function from graphql-js:\n *\n * graphql(\n *   schema: GraphQLSchema,\n *   requestString: string,\n *   rootValue?: ?any,\n *   contextValue?: ?any,\n *   variableValues?: ?{[key: string]: any},\n *   operationName?: ?string\n * ): Promise<GraphQLResult>\n *\n * The default export as of graphql-anywhere is sync as of 4.0,\n * but below is an exported alternative that is async.\n * In the 5.0 version, this will be the only export again\n * and it will be async\n */\nexport function graphql(\n  resolver: Resolver,\n  document: DocumentNode,\n  rootValue?: any,\n  contextValue?: any,\n  variableValues?: VariableMap,\n  execOptions: ExecOptions = {},\n) {\n  const mainDefinition = getMainDefinition(document);\n\n  const fragments = getFragmentDefinitions(document);\n  const fragmentMap = createFragmentMap(fragments);\n\n  const resultMapper = execOptions.resultMapper;\n\n  // Default matcher always matches all fragments\n  const fragmentMatcher = execOptions.fragmentMatcher || (() => true);\n\n  const execContext: ExecContext = {\n    fragmentMap,\n    contextValue,\n    variableValues,\n    resultMapper,\n    resolver,\n    fragmentMatcher,\n  };\n\n  return executeSelectionSet(\n    mainDefinition.selectionSet,\n    rootValue,\n    execContext,\n  );\n}\n\nfunction executeSelectionSet(\n  selectionSet: SelectionSetNode,\n  rootValue: any,\n  execContext: ExecContext,\n) {\n  const { fragmentMap, contextValue, variableValues: variables } = execContext;\n\n  const result = {};\n\n  selectionSet.selections.forEach(selection => {\n    if (!shouldInclude(selection, variables)) {\n      // Skip this entirely\n      return;\n    }\n\n    if (isField(selection)) {\n      const fieldResult = executeField(selection, rootValue, execContext);\n\n      const resultFieldKey = resultKeyNameFromField(selection);\n\n      if (fieldResult !== undefined) {\n        if (result[resultFieldKey] === undefined) {\n          result[resultFieldKey] = fieldResult;\n        } else {\n          merge(result[resultFieldKey], fieldResult);\n        }\n      }\n    } else {\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment\n        fragment = fragmentMap[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}`);\n        }\n      }\n\n      const typeCondition = fragment.typeCondition.name.value;\n\n      if (execContext.fragmentMatcher(rootValue, typeCondition, contextValue)) {\n        const fragmentResult = executeSelectionSet(\n          fragment.selectionSet,\n          rootValue,\n          execContext,\n        );\n\n        merge(result, fragmentResult);\n      }\n    }\n  });\n\n  if (execContext.resultMapper) {\n    return execContext.resultMapper(result, rootValue);\n  }\n\n  return result;\n}\n\nfunction executeField(\n  field: FieldNode,\n  rootValue: any,\n  execContext: ExecContext,\n): any {\n  const { variableValues: variables, contextValue, resolver } = execContext;\n\n  const fieldName = field.name.value;\n  const args = argumentsObjectFromField(field, variables);\n\n  const info: ExecInfo = {\n    isLeaf: !field.selectionSet,\n    resultKey: resultKeyNameFromField(field),\n    directives: getDirectiveInfoFromField(field, variables),\n  };\n\n  const result = resolver(fieldName, rootValue, args, contextValue, info);\n\n  // Handle all scalar types here\n  if (!field.selectionSet) {\n    return result;\n  }\n\n  // From here down, the field has a selection set, which means it's trying to\n  // query a GraphQLObjectType\n  if (result == null) {\n    // Basically any field in a GraphQL response can be null, or missing\n    return result;\n  }\n\n  if (Array.isArray(result)) {\n    return executeSubSelectedArray(field, result, execContext);\n  }\n\n  // Returned value is an object, and the query has a sub-selection. Recurse.\n  return executeSelectionSet(field.selectionSet, result, execContext);\n}\n\nfunction executeSubSelectedArray(field, result, execContext) {\n  return result.map(item => {\n    // null value in array\n    if (item === null) {\n      return null;\n    }\n\n    // This is a nested array, recurse\n    if (Array.isArray(item)) {\n      return executeSubSelectedArray(field, item, execContext);\n    }\n\n    // This is an object, run the selection set on it\n    return executeSelectionSet(field.selectionSet, item, execContext);\n  });\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport function merge(dest, src) {\n  if (src !== null && typeof src === 'object') {\n    Object.keys(src).forEach(key => {\n      const srcVal = src[key];\n      if (!hasOwn.call(dest, key)) {\n        dest[key] = srcVal;\n      } else {\n        merge(dest[key], srcVal);\n      }\n    });\n  }\n}\n","import graphqlAnywhere, { Resolver, ExecInfo } from 'graphql-anywhere';\n\nimport {\n  IdValue,\n  assign,\n  isEqual,\n  getDefaultValues,\n  getQueryDefinition,\n  isJsonValue,\n  isIdValue,\n  toIdValue,\n  getStoreKeyName,\n  StoreValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadQueryOptions,\n  IdValueWithPreviousResult,\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  StoreObject,\n} from './types';\n\n/**\n * The key which the cache id for a given value is stored in the result object. This key is private\n * and should not be used by Apollo client users.\n *\n * Uses a symbol if available in the environment.\n *\n * @private\n */\nexport const ID_KEY = typeof Symbol !== 'undefined' ? Symbol('id') : '@@id';\n\n/**\n * Resolves the result of a query solely from the store (i.e. never hits the server).\n *\n * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n * store.\n *\n * @param {DocumentNode} query The query document to resolve from the data available in the store.\n *\n * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n * be referenced by the query document.\n *\n * @param {any} previousResult The previous result returned by this function for the same query.\n * If nothing in the store changed since that previous result then values from the previous result\n * will be returned to preserve referential equality.\n */\nexport function readQueryFromStore<QueryType>(\n  options: ReadQueryOptions,\n): QueryType {\n  const optsPatch = { returnPartialData: false };\n\n  return diffQueryAgainstStore<QueryType>({\n    ...options,\n    ...optsPatch,\n  }).result;\n}\n\nconst readStoreResolver: Resolver = (\n  fieldName: string,\n  idValue: IdValueWithPreviousResult,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n) => {\n  assertIdValue(idValue);\n\n  const objId = idValue.id;\n  const obj = context.store.get(objId);\n\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | string | void = void 0;\n\n  if (obj) {\n    fieldValue = obj[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      (obj.__typename || objId === 'ROOT_QUERY')\n    ) {\n      const typename = obj.__typename || 'Query';\n\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(obj, args, {\n            getCacheKey(storeObj: StoreObject) {\n              return toIdValue({\n                id: context.dataIdFromObject(storeObj),\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    if (!context.returnPartialData) {\n      throw new Error(\n        `Can't find field ${storeKeyName} on object (${objId}) ${JSON.stringify(\n          obj,\n          null,\n          2,\n        )}.`,\n      );\n    }\n\n    context.hasMissingField = true;\n\n    return fieldValue;\n  }\n\n  // if this is an object scalar, it must be a json blob and we have to unescape it\n  if (isJsonValue(fieldValue)) {\n    // If the JSON blob is the same now as in the previous result, return the previous result to\n    // maintain referential equality.\n    //\n    // `isEqual` will first perform a referential equality check (with `===`) in case the JSON\n    // value has not changed in the store, and then a deep equality check if that fails in case a\n    // new JSON object was returned by the API but that object may still be the same.\n    if (\n      idValue.previousResult &&\n      isEqual(idValue.previousResult[resultKey], fieldValue.json)\n    ) {\n      return idValue.previousResult[resultKey];\n    }\n    return fieldValue.json;\n  }\n\n  // If we had a previous result, try adding that previous result value for this field to our field\n  // value. This will create a new value without mutating the old one.\n  if (idValue.previousResult) {\n    fieldValue = addPreviousResultToIdValues(\n      fieldValue,\n      idValue.previousResult[resultKey],\n    );\n  }\n\n  return fieldValue;\n};\n\n/**\n * Given a store and a query, return as much of the result as possible and\n * identify if any data was missing from the store.\n * @param  {DocumentNode} query A parsed GraphQL query document\n * @param  {Store} store The Apollo Client store object\n * @param  {any} previousResult The previous result returned by this function for the same query\n * @return {result: Object, complete: [boolean]}\n */\nexport function diffQueryAgainstStore<T>({\n  store,\n  query,\n  variables,\n  previousResult,\n  returnPartialData = true,\n  rootId = 'ROOT_QUERY',\n  fragmentMatcherFunction,\n  config,\n}: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n  // Throw the right validation error by trying to find a query in the document\n  const queryDefinition = getQueryDefinition(query);\n\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  const context: ReadStoreContext = {\n    // Global settings\n    store,\n    returnPartialData,\n    dataIdFromObject: (config && config.dataIdFromObject) || null,\n    cacheRedirects: (config && config.cacheRedirects) || {},\n    // Flag set during execution\n    hasMissingField: false,\n  };\n\n  const rootIdValue = {\n    type: 'id',\n    id: rootId,\n    previousResult,\n  };\n\n  const result = graphqlAnywhere(\n    readStoreResolver,\n    query,\n    rootIdValue,\n    context,\n    variables,\n    {\n      fragmentMatcher: fragmentMatcherFunction,\n      resultMapper,\n    },\n  );\n\n  return {\n    result: result as T,\n    complete: !context.hasMissingField,\n  };\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  if (!isIdValue(idValue)) {\n    throw new Error(`Encountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n  }\n}\n\n/**\n * Adds a previous result value to id values in a nested array. For a single id value and a single\n * previous result then the previous value is added directly.\n *\n * For arrays we put all of the ids from the previous result array in a map and add them to id\n * values with the same id.\n *\n * This function does not mutate. Instead it returns new instances of modified values.\n *\n * @private\n */\nfunction addPreviousResultToIdValues(value: any, previousResult: any): any {\n  // If the value is an `IdValue`, add the previous result to it whether or not that\n  // `previousResult` is undefined.\n  //\n  // If the value is an array, recurse over each item trying to add the `previousResult` for that\n  // item.\n  if (isIdValue(value)) {\n    return {\n      ...value,\n      previousResult,\n    };\n  } else if (Array.isArray(value)) {\n    const idToPreviousResult: Map<string, any> = new Map();\n\n    // If the previous result was an array, we want to build up our map of ids to previous results\n    // using the private `ID_KEY` property that is added in `resultMapper`.\n    if (Array.isArray(previousResult)) {\n      previousResult.forEach(item => {\n        // item can be null\n        if (item && item[ID_KEY]) {\n          idToPreviousResult.set(item[ID_KEY], item);\n          // idToPreviousResult[item[ID_KEY]] = item;\n        }\n      });\n    }\n\n    // For every value we want to add the previous result.\n    return value.map((item, i) => {\n      // By default the previous result for this item will be in the same array position as this\n      // item.\n      let itemPreviousResult = previousResult && previousResult[i];\n\n      // If the item is an id value, we should check to see if there is a previous result for this\n      // specific id. If there is, that will be the value for `itemPreviousResult`.\n      if (isIdValue(item)) {\n        itemPreviousResult =\n          idToPreviousResult.get(item.id) || itemPreviousResult;\n      }\n\n      return addPreviousResultToIdValues(item, itemPreviousResult);\n    });\n  }\n  // Return the value, nothing changed.\n  return value;\n}\n\n/**\n * Maps a result from `graphql-anywhere` to a final result value.\n *\n * If the result and the previous result from the `idValue` pass a shallow equality test, we just\n * return the `previousResult` to maintain referential equality.\n *\n * We also add a private id property to the result that we can use later on.\n *\n * @private\n */\nfunction resultMapper(resultFields: any, idValue: IdValueWithPreviousResult) {\n  // If we had a previous result, we may be able to return that and preserve referential equality\n  if (idValue.previousResult) {\n    const currentResultKeys = Object.keys(resultFields);\n\n    const sameAsPreviousResult =\n      // Confirm that we have the same keys in both the current result and the previous result.\n      Object.keys(idValue.previousResult).every(\n        key => currentResultKeys.indexOf(key) > -1,\n      ) &&\n      // Perform a shallow comparison of the result fields with the previous result. If all of\n      // the shallow fields are referentially equal to the fields of the previous result we can\n      // just return the previous result.\n      //\n      // While we do a shallow comparison of objects, but we do a deep comparison of arrays.\n      currentResultKeys.every(key =>\n        areNestedArrayItemsStrictlyEqual(\n          resultFields[key],\n          idValue.previousResult[key],\n        ),\n      );\n\n    if (sameAsPreviousResult) {\n      return idValue.previousResult;\n    }\n  }\n\n  Object.defineProperty(resultFields, ID_KEY, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: idValue.id,\n  });\n\n  return resultFields;\n}\n\ntype NestedArray<T> = T | Array<T | Array<T | Array<T>>>;\n\n/**\n * Compare all the items to see if they are all referentially equal in two arrays no matter how\n * deeply nested the arrays are.\n *\n * @private\n */\nfunction areNestedArrayItemsStrictlyEqual(\n  a: NestedArray<any>,\n  b: NestedArray<any>,\n): boolean {\n  // If `a` and `b` are referentially equal, return true.\n  if (a === b) {\n    return true;\n  }\n  // If either `a` or `b` are not an array or not of the same length return false. `a` and `b` are\n  // known to not be equal here, we checked above.\n  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {\n    return false;\n  }\n  // Otherwise let us compare all of the array items (which are potentially nested arrays!) to see\n  // if they are equal.\n  return a.every((item, i) => areNestedArrayItemsStrictlyEqual(item, b[i]));\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class RecordingCache implements NormalizedCache {\n  private recordedData: NormalizedCacheObject = {};\n\n  constructor(private readonly data: NormalizedCacheObject = {}) {}\n\n  public record(\n    transaction: (recordingCache: RecordingCache) => void,\n  ): NormalizedCacheObject {\n    transaction(this);\n    const recordedData = this.recordedData;\n    this.recordedData = {};\n    return recordedData;\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data, ...this.recordedData };\n  }\n\n  public get(dataId: string): StoreObject {\n    if (this.recordedData.hasOwnProperty(dataId)) {\n      // recording always takes precedence:\n      return this.recordedData[dataId];\n    }\n    return this.data[dataId];\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    if (this.get(dataId) !== value) {\n      this.recordedData[dataId] = value;\n    }\n  }\n\n  public delete(dataId: string): void {\n    this.recordedData[dataId] = undefined;\n  }\n\n  public clear(): void {\n    Object.keys(this.data).forEach(dataId => this.delete(dataId));\n    this.recordedData = {};\n  }\n\n  public replace(newData: NormalizedCacheObject): void {\n    this.clear();\n    this.recordedData = { ...newData };\n  }\n}\n\nexport function record(\n  startingState: NormalizedCacheObject,\n  transaction: (recordingCache: RecordingCache) => void,\n): NormalizedCacheObject {\n  const recordingCache = new RecordingCache(startingState);\n  return recordingCache.record(transaction);\n}\n","import { DocumentNode } from 'graphql';\n\nimport { Cache, DataProxy, ApolloCache, Transaction } from 'apollo-cache';\n\nimport {\n  getFragmentQueryDocument,\n  addTypenameToDocument,\n} from 'apollo-utilities';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  OptimisticStoreItem,\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\nimport { writeResultToStore } from './writeToStore';\nimport { readQueryFromStore, diffQueryAgainstStore } from './readFromStore';\nimport { defaultNormalizedCacheFactory } from './objectCache';\nimport { record } from './recordingCache';\nconst defaultConfig: ApolloReducerConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  storeFactory: defaultNormalizedCacheFactory,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  protected data: NormalizedCache;\n  protected config: ApolloReducerConfig;\n  protected optimistic: OptimisticStoreItem[] = [];\n  private watches: Cache.WatchOptions[] = [];\n  private addTypename: boolean;\n  private typenameDocumentCache = new WeakMap<DocumentNode, DocumentNode>();\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: ApolloReducerConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      console.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      console.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = this.config.addTypename;\n    this.data = this.config.storeFactory();\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    if (optimistic && this.optimistic.length > 0) {\n      const patches = this.optimistic.map(opt => opt.data);\n      return Object.assign({}, this.data.toObject(), ...patches);\n    }\n\n    return this.data.toObject();\n  }\n\n  public read<T>(query: Cache.ReadOptions): T | null {\n    if (query.rootId && this.data.get(query.rootId) === undefined) {\n      return null;\n    }\n\n    return readQueryFromStore({\n      store: this.config.storeFactory(this.extract(query.optimistic)),\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      rootId: query.rootId,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      previousResult: query.previousResult,\n      config: this.config,\n    });\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    return diffQueryAgainstStore({\n      store: this.config.storeFactory(this.extract(query.optimistic)),\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.push(watch);\n\n    return () => {\n      this.watches = this.watches.filter(c => c !== watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new Error(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(id: string) {\n    // Throw away optimistic changes of that particular mutation\n    const toPerform = this.optimistic.filter(item => item.id !== id);\n\n    this.optimistic = [];\n\n    // Re-run all of our optimistic data actions on top of one another.\n    toPerform.forEach(change => {\n      this.recordOptimisticTransaction(change.transaction, change.id);\n    });\n\n    this.broadcastWatches();\n  }\n\n  public performTransaction(transaction: Transaction<NormalizedCacheObject>) {\n    // TODO: does this need to be different, or is this okay for an in-memory cache?\n\n    let alreadySilenced = this.silenceBroadcast;\n    this.silenceBroadcast = true;\n\n    transaction(this);\n\n    if (!alreadySilenced) {\n      // Don't un-silence since this is a nested transaction\n      // (for example, a transaction inside an optimistic record)\n      this.silenceBroadcast = false;\n    }\n\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    this.silenceBroadcast = true;\n\n    const patch = record(this.extract(true), recordingCache => {\n      // swapping data instance on 'this' is currently necessary\n      // because of the current architecture\n      const dataCache = this.data;\n      this.data = recordingCache;\n      this.performTransaction(transaction);\n      this.data = dataCache;\n    });\n\n    this.optimistic.push({\n      id,\n      transaction,\n      data: patch,\n    });\n\n    this.silenceBroadcast = false;\n\n    this.broadcastWatches();\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        this.typenameDocumentCache.set(\n          document,\n          (result = addTypenameToDocument(document)),\n        );\n      }\n      return result;\n    }\n    return document;\n  }\n\n  public readQuery<QueryType, TVariables = any>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): QueryType {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment<TData = any, TVariables = any>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n    });\n  }\n\n  protected broadcastWatches() {\n    // Skip this when silenced (like inside a transaction)\n    if (this.silenceBroadcast) return;\n\n    // right now, we invalidate all queries whenever anything changes\n    this.watches.forEach((c: Cache.WatchOptions) => {\n      const newData = this.diff({\n        query: c.query,\n        variables: c.variables,\n\n        // TODO: previousResult isn't in the types - this will only work\n        // with ObservableQuery which is in a different package\n        previousResult: (c as any).previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      });\n\n      c.callback(newData);\n    });\n  }\n}\n","import { Operation } from 'apollo-link';\nimport { print } from 'graphql/language/printer';\n\n/*\n * Http Utilities: shared across links that make http requests\n */\n\n// XXX replace with actual typings when available\ndeclare var AbortController: any;\n\n//Used for any Error for data from the server\n//on a request with a Status >= 300\n//response contains no data or errors\nexport type ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\n//Thrown when server's resonse is cannot be parsed\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport type ClientParseError = Error & {\n  parseError: Error;\n};\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: any; //overrides headers in options\n  credentials?: any;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\n// The body of a GraphQL-over-HTTP-POST request.\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: GlobalFetch['fetch'];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: any;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: '*/*',\n  'content-type': 'application/json',\n};\n\nconst defaultOptions = {\n  method: 'POST',\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const throwServerError = (response, result, message) => {\n  const error = new Error(message) as ServerError;\n\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\n//TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>\nexport const parseAndCheckHttpResponse = operations => (response: Response) => {\n  return (\n    response\n      .text()\n      .then(bodyText => {\n        try {\n          return JSON.parse(bodyText);\n        } catch (err) {\n          const parseError = err as ServerParseError;\n          parseError.response = response;\n          parseError.statusCode = response.status;\n          parseError.bodyText = bodyText;\n          return Promise.reject(parseError);\n        }\n      })\n      //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult\n      .then((result: any) => {\n        if (response.status >= 300) {\n          //Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`,\n          );\n        }\n        //TODO should really error per response in a Batch based on properties\n        //    - could be done in a validation link\n        if (\n          !Array.isArray(result) &&\n          !result.hasOwnProperty('data') &&\n          !result.hasOwnProperty('errors')\n        ) {\n          //Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map(op => op.operationName)\n                : operations.operationName\n            }'.`,\n          );\n        }\n        return result;\n      })\n  );\n};\n\nexport const checkFetcher = (fetcher: GlobalFetch['fetch']) => {\n  if (!fetcher && typeof fetch === 'undefined') {\n    let library: string = 'unfetch';\n    if (typeof window === 'undefined') library = 'node-fetch';\n    throw new Error(`\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/${library}.\n\nFor example:\nimport fetch from '${library}';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });`);\n  }\n};\n\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === 'undefined')\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n\nexport const selectHttpOptionsAndBody = (\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) => {\n  let options: HttpConfig & Record<string, any> = {\n    ...fallbackConfig.options,\n    headers: fallbackConfig.headers,\n    credentials: fallbackConfig.credentials,\n  };\n  let http: HttpQueryOptions = fallbackConfig.http;\n\n  /*\n   * use the rest of the configs to populate the options\n   * configs later in the list will overwrite earlier fields\n   */\n  configs.forEach(config => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n    if (config.credentials) options.credentials = config.credentials;\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = print(query);\n\n  return {\n    options,\n    body,\n  };\n};\n\nexport const serializeFetchParameter = (p, label) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    const parseError = new Error(\n      `Network request failed. ${label} is not serializable: ${e.message}`,\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n\n//selects \"/graphql\" by default\nexport const selectURI = (\n  operation,\n  fallbackURI?: string | ((operation: Operation) => string),\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === 'function') {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || '/graphql';\n  }\n};\n","/* tslint:disable */\n\nimport { ApolloLink, Observable, RequestHandler, fromError } from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  checkFetcher,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  Body,\n  HttpOptions,\n  UriFunction as _UriFunction,\n} from 'apollo-link-http-common';\nimport { DefinitionNode } from 'graphql';\n\nexport namespace HttpLink {\n  //TODO Would much rather be able to export directly\n  export interface UriFunction extends _UriFunction {}\n  export interface Options extends HttpOptions {\n    /**\n     * If set to true, use the HTTP GET method for query operations. Mutations\n     * will still use the method specified in fetchOptions.method (which defaults\n     * to POST).\n     */\n    useGETForQueries?: boolean;\n  }\n}\n\n// For backwards compatibility.\nexport import FetchOptions = HttpLink.Options;\nexport import UriFunction = HttpLink.UriFunction;\n\nexport const createHttpLink = (linkOptions: HttpLink.Options = {}) => {\n  let {\n    uri = '/graphql',\n    // use default global fetch is nothing passed in\n    fetch: fetcher,\n    includeExtensions,\n    useGETForQueries,\n    ...requestOptions\n  } = linkOptions;\n\n  // dev warnings to ensure fetch is present\n  checkFetcher(fetcher);\n\n  //fetcher is set here rather than the destructuring to ensure fetch is\n  //declared before referencing it. Reference in the destructuring would cause\n  //a ReferenceError\n  if (!fetcher) {\n    fetcher = fetch;\n  }\n\n  const linkConfig = {\n    http: { includeExtensions },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink(operation => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: context.headers,\n    };\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBody(\n      operation,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig,\n    );\n\n    let controller;\n    if (!(options as any).signal) {\n      const { controller: _controller, signal } = createSignalIfSupported();\n      controller = _controller;\n      if (controller) (options as any).signal = signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n    };\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = 'GET';\n    }\n\n    if (options.method === 'GET') {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, 'Payload');\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable(observer => {\n      fetcher(chosenURI, options)\n        .then(response => {\n          operation.setContext({ response });\n          return response;\n        })\n        .then(parseAndCheckHttpResponse(operation))\n        .then(result => {\n          // we have data and can send it to back up the link chain\n          observer.next(result);\n          observer.complete();\n          return result;\n        })\n        .catch(err => {\n          // fetch was cancelled so its already been cleaned up in the unsubscribe\n          if (err.name === 'AbortError') return;\n          // if it is a network error, BUT there is graphql result info\n          // fire the next observer before calling error\n          // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n          // to pass to UI\n          // this should only happen if we *also* have data as part of the response key per\n          // the spec\n          if (err.result && err.result.errors && err.result.data) {\n            // if we dont' call next, the UI can only show networkError because AC didn't\n            // get andy graphqlErrors\n            // this is graphql execution result info (i.e errors and possibly data)\n            // this is because there is no formal spec how errors should translate to\n            // http status codes. So an auth error (401) could have both data\n            // from a public field, errors from a private field, and a status of 401\n            // {\n            //  user { // this will have errors\n            //    firstName\n            //  }\n            //  products { // this is public so will have data\n            //    cost\n            //  }\n            // }\n            //\n            // the result of above *could* look like this:\n            // {\n            //   data: { products: [{ cost: \"$10\" }] },\n            //   errors: [{\n            //      message: 'your session has timed out',\n            //      path: []\n            //   }]\n            // }\n            // status code of above would be a 401\n            // in the UI you want to show data where you can, errors as data where you can\n            // and use correct http status codes\n            observer.next(err.result);\n          }\n          observer.error(err);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '',\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n\nexport class HttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(opts?: HttpLink.Options) {\n    super(createHttpLink(opts).request);\n  }\n}\n","import { Data, Field } from \"../support/interfaces\";\nimport Model from \"../orm/model\";\nimport { Model as ORMModel } from \"@vuex-orm/core\";\nimport Context from \"../common/context\";\nimport { clone, downcaseFirstLetter, isPlainObject } from \"../support/utils\";\nconst inflection = require(\"inflection\");\n\n/**\n * This class provides methods to transform incoming data from GraphQL in to a format Vuex-ORM understands and\n * vice versa.\n */\nexport default class Transformer {\n  /**\n   * Transforms outgoing data. Use for variables param.\n   *\n   * Omits relations and some other fields.\n   *\n   * @param model\n   * @param {Data} data\n   * @param {Array<String>} whitelist of fields\n   * @returns {Data}\n   */\n  public static transformOutgoingData(model: Model, data: Data, whitelist?: Array<String>): Data {\n    const context = Context.getInstance();\n    const relations: Map<string, Field> = model.getRelations();\n    const returnValue: Data = {};\n\n    Object.keys(data).forEach(key => {\n      const value = data[key];\n\n      if (key === \"comments\") {\n        console.log(\"model\", model, model.baseModel.$entitiy, model.constructor.name);\n        console.log(\"data\", data);\n        console.log(\"whitelist\", whitelist);\n      }\n\n      // Always add fields on the whitelist. Ignore hasMany/One connections, empty fields and internal fields ($)\n      if (\n        (whitelist && whitelist.includes(key)) ||\n        ((!relations.has(key) || relations.get(key) instanceof context.components.BelongsTo) &&\n          !key.startsWith(\"$\") &&\n          value !== null &&\n          value !== undefined)\n      ) {\n        let relatedModel =\n          relations.get(key) && relations.get(key)!.parent\n            ? context.getModel(inflection.singularize(relations.get(key)!.parent!.entity), true)\n            : null;\n        if (value instanceof Array) {\n          // Iterate over all fields and transform them if value is an array\n          const arrayModel = context.getModel(inflection.singularize(key));\n          returnValue[key] = value.map(v => this.transformOutgoingData(arrayModel || model, v));\n        } else if (typeof value === \"object\" && value.$id !== undefined) {\n          if (!relatedModel) {\n            relatedModel = context.getModel((value as ORMModel).$self().entity);\n          }\n\n          // Value is a record, transform that too\n          returnValue[key] = this.transformOutgoingData(relatedModel, value);\n        } else {\n          // In any other case just let the value be what ever it is\n          returnValue[key] = value;\n        }\n      }\n    });\n\n    return returnValue;\n  }\n\n  /**\n   * Transforms a set of incoming data to the format vuex-orm requires.\n   *\n   * @param {Data | Array<Data>} data\n   * @param model\n   * @param mutation required to transform something like `disableUserAddress` to the actual model name.\n   * @param {boolean} recursiveCall\n   * @returns {Data}\n   */\n  public static transformIncomingData(\n    data: Data | Array<Data>,\n    model: Model,\n    mutation: boolean = false,\n    recursiveCall: boolean = false\n  ): Data {\n    let result: Data = {};\n    const context = Context.getInstance();\n\n    if (!recursiveCall) {\n      context.logger.group(\"Transforming incoming data\");\n      context.logger.log(\"Raw data:\", data);\n    }\n\n    if (Array.isArray(data)) {\n      result = data.map((d: any) => this.transformIncomingData(d, model, mutation, true));\n    } else {\n      Object.keys(data).forEach(key => {\n        if (data[key] !== undefined && data[key] !== null) {\n          if (isPlainObject(data[key])) {\n            const localModel: Model = context.getModel(key, true) || model;\n\n            if (data[key].nodes && context.connectionQueryMode === \"nodes\") {\n              result[inflection.pluralize(key)] = this.transformIncomingData(\n                data[key].nodes,\n                localModel,\n                mutation,\n                true\n              );\n            } else if (data[key].edges && context.connectionQueryMode === \"edges\") {\n              result[inflection.pluralize(key)] = this.transformIncomingData(\n                data[key].edges,\n                localModel,\n                mutation,\n                true\n              );\n            } else if (data[\"node\"] && context.connectionQueryMode === \"edges\") {\n              result = this.transformIncomingData(data[\"node\"], localModel, mutation, true);\n            } else {\n              let newKey = key;\n\n              if (mutation && !recursiveCall) {\n                newKey = data[key].nodes ? localModel.pluralName : localModel.singularName;\n                newKey = downcaseFirstLetter(newKey);\n              }\n\n              result[newKey] = this.transformIncomingData(data[key], localModel, mutation, true);\n            }\n          } else if (Model.isFieldNumber(model.fields.get(key))) {\n            result[key] = parseFloat(data[key]);\n          } else if (key.endsWith(\"Type\") && model.isTypeFieldOfPolymorphicRelation(key)) {\n            result[key] = inflection.pluralize(downcaseFirstLetter(data[key]));\n          } else {\n            result[key] = data[key];\n          }\n        }\n      });\n    }\n\n    if (!recursiveCall) {\n      context.logger.log(\"Transformed data:\", result);\n      context.logger.groupEnd();\n    } else {\n      result[\"$isPersisted\"] = true;\n    }\n\n    // Make sure this is really a plain JS object. We had some issues in testing here.\n    return clone(result);\n  }\n}\n","var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n","import { ApolloClient, FetchPolicy } from 'apollo-client';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\nimport { HttpLink } from 'apollo-link-http';\nimport { ApolloLink } from 'apollo-link';\nimport Context from '../common/context';\nimport { Arguments, Data } from '../support/interfaces';\nimport Transformer from './transformer';\nimport Model from '../orm/model';\nimport gql from 'graphql-tag';\n\n/**\n * This class takes care of the communication with the graphql endpoint by leveraging the awesome apollo-client lib.\n */\nexport default class Apollo {\n  /**\n   * The http link instance to use.\n   * @type {HttpLink}\n   */\n  private readonly httpLink: ApolloLink;\n\n  /**\n   * The ApolloClient instance\n   * @type {ApolloClient}\n   */\n  private readonly apolloClient: ApolloClient<any>;\n\n  /**\n   * @constructor\n   */\n  public constructor () {\n    const context = Context.getInstance();\n\n    // This allows the test suite to pass a custom link\n    if (context.options.link) {\n      this.httpLink = context.options.link;\n    } else {\n      this.httpLink = new HttpLink({\n        uri: context.options.url ? context.options.url : '/graphql',\n        credentials: context.options.credentials ? context.options.credentials : 'same-origin',\n        useGETForQueries: Boolean(context.options.useGETForQueries)\n      });\n    }\n\n    this.apolloClient = new ApolloClient({\n      link: this.httpLink,\n      cache: new InMemoryCache(),\n      connectToDevTools: context.debugMode\n    });\n  }\n\n  /**\n   * Sends a request to the GraphQL API via apollo\n   * @param model\n   * @param {any} query The query to send (result from gql())\n   * @param {Arguments} variables Optional. The variables to send with the query\n   * @param {boolean} mutation Optional. If this is a mutation (true) or a query (false, default)\n   * @param {boolean} bypassCache If true the query will be send to the server without using the cache. For queries only\n   * @returns {Promise<Data>} The new records\n   */\n  public async request (model: Model, query: any, variables?: Arguments, mutation: boolean = false,\n                        bypassCache: boolean = false): Promise<Data> {\n\n    const fetchPolicy: FetchPolicy = bypassCache ? 'network-only' : 'cache-first';\n    Context.getInstance().logger.logQuery(query, variables, fetchPolicy);\n\n    const context = { headers: Apollo.getHeaders() };\n\n    let response;\n    if (mutation) {\n      response = await this.apolloClient.mutate({ mutation: query, variables, context });\n    } else {\n      response = await this.apolloClient.query({ query, variables, fetchPolicy, context });\n    }\n\n    // Transform incoming data into something useful\n    return Transformer.transformIncomingData(response.data as Data, model, mutation);\n  }\n\n  public async simpleQuery (query: string, variables: Arguments, bypassCache: boolean = false, context?: Data): Promise<any> {\n    const fetchPolicy: FetchPolicy = bypassCache ? 'network-only' : 'cache-first';\n    return this.apolloClient.query({ query: gql(query), variables, fetchPolicy, context: { headers: Apollo.getHeaders() } });\n  }\n\n  public async simpleMutation (query: string, variables: Arguments, context?: Data): Promise<any> {\n    return this.apolloClient.mutate({ mutation: gql(query), variables, context: { headers: Apollo.getHeaders() } });\n  }\n\n  private static getHeaders () {\n    const context = Context.getInstance();\n\n    let headers: Object | Function = context.options.headers ? context.options.headers : {};\n\n    if (headers instanceof Function) {\n      headers = headers(context);\n    }\n\n    return headers;\n  }\n}\n","import { GraphQLField, GraphQLSchema, GraphQLType, GraphQLTypeDefinition } from '../support/interfaces';\nimport { upcaseFirstLetter } from '../support/utils';\n\nexport default class Schema {\n  private schema: GraphQLSchema;\n  private types: Map<string, GraphQLType>;\n  private mutations: Map<string, GraphQLField>;\n  private queries: Map<string, GraphQLField>;\n\n  public constructor (schema: GraphQLSchema) {\n    this.schema = schema;\n    this.types = new Map<string, GraphQLType>();\n    this.mutations = new Map<string, GraphQLField>();\n    this.queries = new Map<string, GraphQLField>();\n\n    this.schema.types.forEach((t: GraphQLType) => this.types.set(t.name, t));\n\n    this.getType('Query')!.fields!.forEach(f => this.queries.set(f.name, f));\n    this.getType('Mutation')!.fields!.forEach(f => this.mutations.set(f.name, f));\n  }\n\n  public determineQueryMode (): string {\n    let connection: GraphQLType | null = null;\n\n    this.queries.forEach((query) => {\n      const typeName = Schema.getTypeNameOfField(query);\n      if (typeName.endsWith('TypeConnection')) {\n        connection = this.getType(typeName);\n        return false; // break\n      }\n      return true;\n    });\n\n    if (!connection) {\n      throw new Error(\"Can't determine the connection mode due to the fact that here are no connection types in the schema. Please set the connectionQueryMode via Vuex-ORM-GraphQL options!\");\n    }\n\n    if (connection!.fields!.find(f => f.name === 'nodes')) {\n      return 'nodes';\n    } else if (connection!.fields!.find(f => f.name === 'edges')) {\n      return 'edges';\n    } else {\n      return 'plain';\n    }\n  }\n\n  public getType (name: string, allowNull: boolean = false): GraphQLType | null {\n    name = upcaseFirstLetter(name);\n    const type = this.types.get(name);\n\n    if (!allowNull && !type) throw new Error(`Couldn't find Type of name ${name} in the GraphQL Schema.`);\n\n    return type || null;\n  }\n\n  public getMutation (name: string, allowNull: boolean = false): GraphQLField | null {\n    const mutation = this.mutations.get(name);\n\n    if (!allowNull && !mutation) throw new Error(`Couldn't find Mutation of name ${name} in the GraphQL Schema.`);\n\n    return mutation || null;\n  }\n\n  public getQuery (name: string, allowNull: boolean = false): GraphQLField | null {\n    const query = this.queries.get(name);\n\n    if (!allowNull && !query) throw new Error(`Couldn't find Query of name ${name} in the GraphQL Schema.`);\n\n    return query || null;\n  }\n\n  static returnsConnection (field: GraphQLField): boolean {\n    return (Schema.getTypeNameOfField(field).endsWith('TypeConnection'));\n  }\n\n  static getRealType (type: GraphQLTypeDefinition): GraphQLTypeDefinition {\n    if (type.kind === 'NON_NULL') {\n      return this.getRealType(type.ofType);\n    } else {\n      return type;\n    }\n  }\n\n  static getTypeNameOfField (field: GraphQLField): string {\n    const type = this.getRealType(field.type);\n\n    if (type.kind === 'LIST') {\n      return `[${type.ofType.name}]`;\n    }\n\n    const name = type.name || type.ofType.name || type.ofType.ofType.name;\n\n    if (!name) throw new Error(`Can't find type name for field ${field.name}`);\n\n    return name;\n  }\n}\n","import Logger from \"./logger\";\nimport Model from \"../orm/model\";\nimport { Model as ORMModel } from \"@vuex-orm/core\";\nimport { Components } from \"@vuex-orm/core/lib/plugins/use\";\nimport { downcaseFirstLetter, isEqual, pick } from \"../support/utils\";\nimport Apollo from \"../graphql/apollo\";\nimport Database from \"@vuex-orm/core/lib/database/Database\";\nimport { Field, GraphQLType, Options } from \"../support/interfaces\";\nimport Schema from \"../graphql/schema\";\nimport { Mock, MockOptions } from \"../test-utils\";\nconst inflection = require(\"inflection\");\n\nconst introspectionQuery = `\nquery Introspection {\n  __schema {\n    types {\n      name\n      description\n      fields(includeDeprecated: true) {\n        name\n        description\n        args {\n          name\n          description\n          type {\n            name\n            kind\n\n            ofType {\n              kind\n\n              name\n              ofType {\n                kind\n                name\n\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n\n        type {\n          name\n          kind\n\n          ofType {\n            kind\n\n            name\n            ofType {\n              kind\n              name\n\n              ofType {\n                kind\n                name\n              }\n            }\n          }\n        }\n      }\n\n      inputFields {\n        name\n        description\n        type {\n          name\n          kind\n\n          ofType {\n            kind\n\n            name\n            ofType {\n              kind\n              name\n\n              ofType {\n                kind\n                name\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n`;\n\n/**\n * Internal context of the plugin. This class contains all information, the models, database, logger and so on.\n *\n * It's a singleton class, so just call Context.getInstance() anywhere you need the context.\n */\nexport default class Context {\n  /**\n   * Contains the instance for the singleton pattern.\n   * @type {Context}\n   */\n  public static instance: Context;\n\n  /**\n   * Components collection of Vuex-ORM\n   * @type {Components}\n   */\n  public readonly components: Components;\n\n  /**\n   * The options which have been passed to VuexOrm.install\n   * @type {Options}\n   */\n  public readonly options: Options;\n\n  /**\n   * The Vuex-ORM database\n   * @type {Database}\n   */\n  public readonly database: Database;\n\n  /**\n   * Collection of all Vuex-ORM models wrapped in a Model instance.\n   * @type {Map<any, any>}\n   */\n  public readonly models: Map<string, Model> = new Map();\n\n  /**\n   * When true, the logging is enabled.\n   * @type {boolean}\n   */\n  public readonly debugMode: boolean = false;\n\n  /**\n   * Our nice Vuex-ORM-GraphQL logger\n   * @type {Logger}\n   */\n  public readonly logger: Logger;\n\n  /**\n   * Instance of Apollo which cares about the communication with the graphql endpoint.\n   * @type {Apollo}\n   */\n  public apollo!: Apollo;\n\n  /**\n   * The graphql schema. Is null until the first request.\n   * @type {Schema}\n   */\n  public schema: Schema | undefined;\n\n  /**\n   * Tells if the schema is already loaded or the loading is currently processed.\n   * @type {boolean}\n   */\n  private schemaWillBeLoaded: Promise<Schema> | undefined;\n\n  /**\n   * Defines how to query connections. 'auto' | 'nodes' | 'edges' | 'plain'\n   */\n  public connectionQueryMode: string = \"auto\";\n\n  /**\n   * Container for the global mocks.\n   * @type {Object}\n   */\n  private globalMocks: { [key: string]: Array<Mock> } = {};\n\n  /**\n   * Private constructor, called by the setup method\n   *\n   * @constructor\n   * @param {Components} components The Vuex-ORM Components collection\n   * @param {Options} options The options passed to VuexORM.install\n   */\n  private constructor(components: Components, options: Options) {\n    this.components = components;\n    this.options = options;\n\n    this.database = options.database;\n    this.debugMode = Boolean(options.debug);\n    this.logger = new Logger(this.debugMode);\n\n    if (!options.database) {\n      throw new Error(\"database param is required to initialize vuex-orm-graphql!\");\n    }\n  }\n\n  /**\n   * Get the singleton instance of the context.\n   * @returns {Context}\n   */\n  public static getInstance(): Context {\n    return this.instance;\n  }\n\n  /**\n   * This is called only once and creates a new instance of the Context.\n   * @param {Components} components The Vuex-ORM Components collection\n   * @param {Options} options The options passed to VuexORM.install\n   * @returns {Context}\n   */\n  public static setup(components: Components, options: Options): Context {\n    this.instance = new Context(components, options);\n\n    this.instance.apollo = new Apollo();\n    this.instance.collectModels();\n\n    this.instance.logger.group(\"Context setup\");\n    this.instance.logger.log(\"components\", this.instance.components);\n    this.instance.logger.log(\"options\", this.instance.options);\n    this.instance.logger.log(\"database\", this.instance.database);\n    this.instance.logger.log(\"models\", this.instance.models);\n    this.instance.logger.groupEnd();\n\n    return this.instance;\n  }\n\n  public async loadSchema(): Promise<Schema> {\n    if (!this.schemaWillBeLoaded) {\n      this.schemaWillBeLoaded = new Promise(async (resolve, reject) => {\n        this.logger.log(\"Fetching GraphQL Schema initially ...\");\n\n        if (this.options.connectionQueryMode) {\n          this.connectionQueryMode = this.options.connectionQueryMode;\n        } else {\n          this.connectionQueryMode = \"auto\";\n        }\n\n        // We send a custom header along with the request. This is required for our test suite to mock the schema request.\n        const context = {\n          headers: { \"X-GraphQL-Introspection-Query\": \"true\" }\n        };\n\n        const result = await this.apollo.simpleQuery(introspectionQuery, {}, true, context);\n        this.schema = new Schema(result.data.__schema);\n\n        this.logger.log(\"GraphQL Schema successful fetched\", result);\n\n        this.logger.log(\"Starting to process the schema ...\");\n        this.processSchema();\n        this.logger.log(\"Schema procession done!\");\n\n        resolve(this.schema);\n      });\n    }\n\n    return this.schemaWillBeLoaded;\n  }\n\n  public processSchema() {\n    this.models.forEach((model: Model) => {\n      let type: GraphQLType;\n\n      try {\n        type = this.schema!.getType(model.singularName)!;\n      } catch (error) {\n        this.logger.warn(`Ignoring entity ${model.singularName} because it's not in the schema.`);\n        return;\n      }\n\n      model.fields.forEach((field: Field, fieldName: string) => {\n        if (!type.fields!.find(f => f.name === fieldName)) {\n          this.logger.warn(\n            `Ignoring field ${model.singularName}.${fieldName} because it's not in the schema.`\n          );\n\n          // TODO: Move skipFields to the model\n          model.baseModel.skipFields = model.baseModel.skipFields ? model.baseModel.skipFields : [];\n          if (!model.baseModel.skipFields.includes(fieldName)) {\n            model.baseModel.skipFields.push(fieldName);\n          }\n        }\n      });\n    });\n\n    if (this.connectionQueryMode === \"auto\") {\n      this.connectionQueryMode = this.schema!.determineQueryMode();\n      this.logger.log(\n        `Connection Query Mode is ${this.connectionQueryMode} by automatic detection`\n      );\n    } else {\n      this.logger.log(`Connection Query Mode is ${this.connectionQueryMode} by config`);\n    }\n  }\n\n  /**\n   * Returns a model from the model collection by it's name\n   *\n   * @param {Model|string} model A Model instance, a singular or plural name of the model\n   * @param {boolean} allowNull When true this method returns null instead of throwing an exception when no model was\n   *                            found. Default is false\n   * @returns {Model}\n   */\n  public getModel(model: Model | string, allowNull: boolean = false): Model {\n    if (typeof model === \"string\") {\n      const name: string = inflection.singularize(downcaseFirstLetter(model));\n      model = this.models.get(name) as Model;\n      if (!allowNull && !model) throw new Error(`No such model ${name}!`);\n    }\n\n    return model;\n  }\n\n  /**\n   * Will add a mock for simple mutations or queries. These are model unrelated and have to be\n   * handled  globally.\n   *\n   * @param {Mock} mock - Mock config.\n   */\n  public addGlobalMock(mock: Mock): boolean {\n    if (this.findGlobalMock(mock.action, mock.options)) return false;\n    if (!this.globalMocks[mock.action]) this.globalMocks[mock.action] = [];\n\n    this.globalMocks[mock.action].push(mock);\n    return true;\n  }\n\n  /**\n   * Finds a global mock for the given action and options.\n   *\n   * @param {string} action - Name of the action like 'simpleQuery' or 'simpleMutation'.\n   * @param {MockOptions} options - MockOptions like { name: 'example' }.\n   * @returns {Mock | null} null when no mock was found.\n   */\n  public findGlobalMock(action: string, options: MockOptions | undefined): Mock | null {\n    if (this.globalMocks[action]) {\n      return (\n        this.globalMocks[action].find(m => {\n          if (!m.options || !options) return true;\n\n          const relevantOptions = pick(options, Object.keys(m.options));\n          return isEqual(relevantOptions, m.options || {});\n        }) || null\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Hook to be called by simpleMutation and simpleQuery actions in order to get the global mock\n   * returnValue.\n   *\n   * @param {string} action - Name of the action like 'simpleQuery' or 'simpleMutation'.\n   * @param {MockOptions} options - MockOptions.\n   * @returns {any} null when no mock was found.\n   */\n  public globalMockHook(action: string, options: MockOptions): any {\n    let returnValue: null | { [key: string]: any } = null;\n    const mock = this.findGlobalMock(action, options);\n\n    if (mock) {\n      if (mock.returnValue instanceof Function) {\n        returnValue = mock.returnValue();\n      } else {\n        returnValue = mock.returnValue || null;\n      }\n    }\n\n    return returnValue;\n  }\n\n  /**\n   * Wraps all Vuex-ORM entities in a Model object and saves them into this.models\n   */\n  private collectModels() {\n    this.database.entities.forEach((entity: any) => {\n      const model: Model = new Model(entity.model as ORMModel);\n      this.models.set(model.singularName, model);\n      Model.augment(model);\n    });\n  }\n}\n","import Model from \"../orm/model\";\nimport { Arguments, Field, GraphQLField } from \"../support/interfaces\";\nimport { clone, isPlainObject, takeWhile, upcaseFirstLetter } from \"../support/utils\";\nimport gql from \"graphql-tag\";\nimport Context from \"../common/context\";\nimport Schema from \"./schema\";\n\n/**\n * Contains all logic to build GraphQL queries/mutations.\n */\nexport default class QueryBuilder {\n  /**\n   * Builds a field for the GraphQL query and a specific model\n   *\n   * @param {Model|string} model The model to use\n   * @param {boolean} multiple Determines whether plural/nodes syntax or singular syntax is used.\n   * @param {Arguments} args The args that will be passed to the query field ( user(role: $role) )\n   * @param {Array<Model>} path The relations in this list are ignored (while traversing relations).\n   *                                    Mainly for recursion\n   * @param {string} name Optional name of the field. If not provided, this will be the model name\n   * @param filter\n   * @param {boolean} allowIdFields Optional. Determines if id fields will be ignored for the argument generation.\n   *                                See buildArguments\n   * @returns {string}\n   *\n   * @todo Do we need the allowIdFields param?\n   */\n  public static buildField(\n    model: Model | string,\n    multiple: boolean = true,\n    args?: Arguments,\n    path: Array<string> = [],\n    name?: string,\n    filter: boolean = false,\n    allowIdFields: boolean = false\n  ): string {\n    const context = Context.getInstance();\n    model = context.getModel(model);\n\n    name = name ? name : model.pluralName;\n    const field = context.schema!.getMutation(name, true) || context.schema!.getQuery(name, true);\n\n    let params: string = this.buildArguments(model, args, false, filter, allowIdFields, field);\n    path = path.length === 0 ? [model.singularName] : path;\n\n    const fields = `\n      ${model.getQueryFields().join(\" \")}\n      ${this.buildRelationsQuery(model, path)}\n    `;\n\n    if (multiple) {\n      const header: string = `${name}${params}`;\n\n      if (context.connectionQueryMode === \"nodes\") {\n        return `\n          ${header} {\n            nodes {\n              ${fields}\n            }\n          }\n        `;\n      } else if (context.connectionQueryMode === \"edges\") {\n        return `\n          ${header} {\n            edges {\n              node {\n                ${fields}\n              }\n            }\n          }\n        `;\n      } else {\n        return `\n          ${header} {\n            ${fields}\n          }\n        `;\n      }\n    } else {\n      return `\n        ${name ? name : model.singularName}${params} {\n          ${fields}\n        }\n      `;\n    }\n  }\n\n  /**\n   * Generates a query.\n   * Currently only one root field for the query is possible.\n   * @param {string} type 'mutation' or 'query'\n   * @param {Model | string} model The model this query or mutation affects. This mainly determines the query fields.\n   * @param {string} name Optional name of the query/mutation. Will overwrite the name from the model.\n   * @param {Arguments} args Arguments for the query\n   * @param {boolean} multiple Determines if the root query field is a connection or not (will be passed to buildField)\n   * @param {boolean} filter When true the query arguments are passed via a filter object.\n   * @returns {any} Whatever gql() returns\n   */\n  public static buildQuery(\n    type: string,\n    model: Model | string,\n    name?: string,\n    args?: Arguments,\n    multiple?: boolean,\n    filter?: boolean\n  ) {\n    const context = Context.getInstance();\n\n    // model\n    model = context.getModel(model);\n    if (!model) throw new Error(\"No model provided to build the query!\");\n\n    // args\n    args = args ? clone(args) : {};\n    if (!args) throw new Error(\"args is undefined\");\n\n    Object.keys(args).forEach((key: string) => {\n      if (args && args[key] && isPlainObject(args[key])) {\n        args[key] = { __type: upcaseFirstLetter(key) };\n      }\n    });\n\n    // multiple\n    multiple = multiple === undefined ? !args[\"id\"] : multiple;\n\n    // name\n    if (!name) name = multiple ? model.pluralName : model.singularName;\n\n    // field\n    const field = context.schema!.getMutation(name, true) || context.schema!.getQuery(name, true);\n\n    // build query\n    const query: string =\n      `${type} ${upcaseFirstLetter(name)}${this.buildArguments(\n        model,\n        args,\n        true,\n        filter,\n        true,\n        field\n      )} {\\n` +\n      `  ${this.buildField(model, multiple, args, [], name, filter, true)}\\n` +\n      `}`;\n\n    return gql(query);\n  }\n\n  /**\n   * Generates the arguments string for a graphql query based on a given map.\n   *\n   * There are three types of arguments:\n   *\n   * 1) Signatures with primitive types (signature = true)\n   *      => 'mutation createUser($name: String!)'\n   *\n   * 2) Signatures with object types (signature = true, args = { user: { __type: 'User' }})\n   *      => 'mutation createUser($user: UserInput!)'\n   *\n   * 3) Fields with variables (signature = false)\n   *      => 'user(id: $id)'\n   *\n   * 4) Filter fields with variables (signature = false, filter = true)\n   *      => 'users(filter: { active: $active })'\n   *\n   * @param model\n   * @param {Arguments | undefined} args\n   * @param {boolean} signature When true, then this method generates a query signature instead of key/value pairs\n   * @param filter\n   * @param {boolean} allowIdFields If true, ID fields will be included in the arguments list\n   * @param {GraphQLField} field Optional. The GraphQL mutation or query field\n   * @returns {String}\n   */\n  public static buildArguments(\n    model: Model,\n    args?: Arguments,\n    signature: boolean = false,\n    filter: boolean = false,\n    allowIdFields: boolean = true,\n    field: GraphQLField | null = null\n  ): string {\n    if (args === undefined) return \"\";\n\n    let returnValue: string = \"\";\n    let first: boolean = true;\n\n    if (args) {\n      Object.keys(args).forEach((key: string) => {\n        let value: any = args[key];\n\n        const isForeignKey = model.skipField(key);\n        const skipFieldDueId = (key === \"id\" || isForeignKey) && !allowIdFields;\n\n        let schemaField: GraphQLField | undefined = this.findSchemaFieldForArgument(\n          key,\n          field,\n          model,\n          filter\n        );\n\n        const isConnectionField =\n          schemaField && Schema.getTypeNameOfField(schemaField).endsWith(\"TypeConnection\");\n\n        // Ignore null fields, ids and connections\n        if (value && !skipFieldDueId && !isConnectionField) {\n          let typeOrValue: any = \"\";\n\n          if (signature) {\n            if (isPlainObject(value) && value.__type) {\n              // Case 2 (User!)\n              typeOrValue = value.__type + \"Input!\";\n            } else if (Array.isArray(value) && field) {\n              const arg = QueryBuilder.findSchemaFieldForArgument(key, field, model, filter);\n              if (!arg) {\n                throw new Error(\n                  `The argument ${key} is of type array but it's not possible to determine the type, because it's not in the field ${\n                    field.name\n                  }`\n                );\n              }\n\n              typeOrValue = Schema.getTypeNameOfField(arg) + \"!\";\n            } else if (schemaField && Schema.getTypeNameOfField(schemaField)) {\n              // Case 1, 3 and 4\n              typeOrValue = Schema.getTypeNameOfField(schemaField) + \"!\";\n            } else if (key === \"id\" || isForeignKey) {\n              // Case 1 (ID!)\n              typeOrValue = \"ID!\";\n            } else {\n              // Case 1 (String!)\n              typeOrValue = this.determineAttributeType(model, key, value, field || undefined);\n              typeOrValue = typeOrValue + \"!\";\n            }\n          } else {\n            // Case 3 or 4\n            typeOrValue = `$${key}`;\n          }\n\n          returnValue = `${returnValue}${first ? \"\" : \", \"}${(signature ? \"$\" : \"\") +\n            key}: ${typeOrValue}`;\n\n          first = false;\n        }\n      });\n\n      if (!first) {\n        if (!signature && filter) returnValue = `filter: { ${returnValue} }`;\n        returnValue = `(${returnValue})`;\n      }\n    }\n\n    return returnValue;\n  }\n\n  /**\n   * Determines the GraphQL primitive type of a field in the variables hash by the field type or (when\n   * the field type is generic attribute) by the variable type.\n   * @param {Model} model\n   * @param {string} key\n   * @param {string} value\n   * @param {GraphQLField} query Pass when we have to detect the type of an argument\n   * @returns {string}\n   */\n  public static determineAttributeType(\n    model: Model,\n    key: string,\n    value: any,\n    query?: GraphQLField\n  ): string {\n    const context: Context = Context.getInstance();\n    const field: undefined | Field = model.fields.get(key);\n    let schemaField: undefined | GraphQLField;\n\n    if (query) {\n      schemaField = query.args.find(f => f.name === key);\n\n      if (!schemaField) {\n        const filterField = query.args.find(f => f.name === \"filter\");\n\n        if (filterField) {\n          schemaField = this.findSchemaFieldForArgument(key, null, model, true);\n        }\n      }\n    } else {\n      schemaField = context.schema!.getType(model.singularName)!.fields!.find(f => f.name === key);\n    }\n\n    if (schemaField && Schema.getTypeNameOfField(schemaField)) {\n      return Schema.getTypeNameOfField(schemaField);\n    } else {\n      if (field instanceof context.components.String) {\n        return \"String\";\n      } else if (field && field instanceof context.components.Number) {\n        return \"Int\";\n      } else if (field && field instanceof context.components.Boolean) {\n        return \"Boolean\";\n      } else {\n        if (typeof value === \"number\") return \"Int\";\n        if (typeof value === \"string\") return \"String\";\n        if (typeof value === \"boolean\") return \"Boolean\";\n\n        throw new Error(\n          `Can't find suitable graphql type for field '${model.singularName}.${key}'.`\n        );\n      }\n    }\n  }\n\n  private static findSchemaFieldForArgument(\n    name: String,\n    field: GraphQLField | null,\n    model: Model,\n    isFilter: boolean\n  ): GraphQLField | undefined {\n    const schema = Context.getInstance().schema!;\n    let schemaField: GraphQLField | undefined;\n\n    if (field) {\n      schemaField = field.args.find(f => f.name === name);\n      if (schemaField) return schemaField;\n    }\n\n    // We try to find the FilterType or at least the Type this query belongs to.\n    const type = schema.getType(model.singularName + (isFilter ? \"Filter\" : \"\"), true);\n\n    // Next we try to find the field from the type\n    schemaField = type\n      ? (isFilter ? type.inputFields! : type.fields!).find(f => f.name === name)\n      : undefined;\n\n    // Warn before we return null\n    if (!schemaField) {\n      Context.getInstance().logger.warn(\n        `Couldn't find the argument with name ${name} for the mutation/query ${\n          field ? field.name : \"(?)\"\n        }`\n      );\n    }\n\n    return schemaField;\n  }\n\n  /**\n   * Generates the fields for all related models.\n   *\n   * @param {Model} model\n   * @param {Array<Model>} path\n   * @returns {string}\n   */\n  static buildRelationsQuery(model: null | Model, path: Array<string> = []): string {\n    if (model === null) return \"\";\n\n    const context = Context.getInstance();\n    const relationQueries: Array<string> = [];\n\n    model.getRelations().forEach((field: Field, name: string) => {\n      let relatedModel: Model;\n\n      if (field.related) {\n        relatedModel = context.getModel(field.related.entity);\n      } else if (field.parent) {\n        relatedModel = context.getModel(field.parent.entity);\n      } else {\n        relatedModel = context.getModel(name);\n        context.logger.log(\n          \"WARNING: field has neither parent nor related property. Fallback to attribute name\",\n          field\n        );\n      }\n\n      // We will ignore the field, when it's already in the path. Means: When it's already queried. However there are\n      // cases where the model will have a relationship to itself. For example a nested category strucure where the\n      // category model has a parent: belongsTo(Category). So we also check if the model references itself. If this is\n      // the case, we allow the nesting up to 5 times.\n      const referencesItSelf = takeWhile(\n        path.slice(0).reverse(),\n        (p: string) => p === relatedModel.singularName\n      ).length;\n      const ignore = referencesItSelf\n        ? referencesItSelf > 5\n        : path.includes(relatedModel.singularName);\n\n      // console.log(`-----> Will ${ignore ? '' : 'not'} ignore ${model.singularName}.${name}, path: ${path.join('.')}`);\n\n      if (model.shouldEagerLoadRelation(name, field, relatedModel) && !ignore) {\n        const newPath = path.slice(0);\n        newPath.push(relatedModel.singularName);\n\n        relationQueries.push(\n          this.buildField(relatedModel, Model.isConnection(field), undefined, newPath, name, false)\n        );\n      }\n    });\n\n    return relationQueries.join(\"\\n\");\n  }\n}\n","import { Data, DispatchFunction } from '../support/interfaces';\nimport Context from '../common/context';\n\n/**\n * Provides some helper methods to interact with the Vuex-ORM store\n */\nexport class Store {\n  /**\n   * Inserts incoming data into the store. Existing data will be updated.\n   *\n   * @param {Data} data New data to insert/update\n   * @param {Function} dispatch Vuex Dispatch method for the model\n   * @return {Promise<Data>} Inserted data as hash\n   */\n  public static async insertData (data: Data, dispatch: DispatchFunction): Promise<Data> {\n    let insertedData: Data = {};\n\n    await Promise.all(Object.keys(data).map(async (key) => {\n      const value = data[key];\n      Context.getInstance().logger.log('Inserting records', value);\n      const newData = await dispatch('insertOrUpdate', { data: value });\n\n      Object.keys(newData).forEach((dataKey) => {\n        if (!insertedData[dataKey]) insertedData[dataKey] = [];\n        insertedData[dataKey] = insertedData[dataKey].concat(newData[dataKey]);\n      });\n    }));\n\n    return insertedData;\n  }\n}\n","import Model from \"../orm/model\";\nimport { upcaseFirstLetter } from \"../support/utils\";\n\n/**\n * Generic name generator for mutations and queries. In the future these methods may be influenced by the configuration.\n */\nexport default class NameGenerator {\n  public static getNameForPersist(model: Model) {\n    return this.getCRUDName(\"create\", model);\n  }\n\n  public static getNameForPush(model: Model) {\n    return this.getCRUDName(\"update\", model);\n  }\n\n  public static getNameForDestroy(model: Model) {\n    return this.getCRUDName(\"delete\", model);\n  }\n\n  public static getNameForFetch(model: Model, plural: boolean = false) {\n    return plural ? model.pluralName : model.singularName;\n  }\n\n  /**\n   * Internal helper to keep the code DRY. Just generates a name by leveraging the models singular name.\n   * @param {string} action Name of the action like 'create'\n   * @param {Model} model\n   * @returns {string} For example 'createBlogPost'\n   */\n  private static getCRUDName(action: string, model: Model) {\n    return `${action}${upcaseFirstLetter(model.singularName)}`;\n  }\n}\n","import QueryBuilder from \"../graphql/query-builder\";\nimport Context from \"../common/context\";\nimport { Store } from \"../orm/store\";\nimport { Arguments, Data, DispatchFunction } from \"../support/interfaces\";\nimport Model from \"../orm/model\";\nimport RootState from \"@vuex-orm/core/lib/modules/contracts/RootState\";\nimport Transformer from \"../graphql/transformer\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport Schema from \"../graphql/schema\";\n\nconst inflection = require(\"inflection\");\n\n/**\n * Base class for all Vuex actions. Contains some utility and convenience methods.\n */\nexport default class Action {\n  /**\n   * Sends a mutation.\n   *\n   * @param {string} name Name of the mutation like 'createUser'\n   * @param {Data | undefined} variables Variables to send with the mutation\n   * @param {Function} dispatch Vuex Dispatch method for the model\n   * @param {Model} model The model this mutation affects.\n   * @param {boolean} multiple Tells if we're requesting a single record or multiple.\n   * @returns {Promise<any>}\n   */\n  protected static async mutation(\n    name: string,\n    variables: Data | undefined,\n    dispatch: DispatchFunction,\n    model: Model\n  ): Promise<any> {\n    if (variables) {\n      const context: Context = Context.getInstance();\n      const schema: Schema = await context.loadSchema();\n\n      const multiple: boolean = Schema.returnsConnection(schema.getMutation(name)!);\n      const query = QueryBuilder.buildQuery(\"mutation\", model, name, variables, multiple);\n\n      // Send GraphQL Mutation\n      let newData = await Context.getInstance().apollo.request(model, query, variables, true);\n\n      // When this was not a destroy action, we get new data, which we should insert in the store\n      if (name !== NameGenerator.getNameForDestroy(model)) {\n        newData = newData[Object.keys(newData)[0]];\n\n        // IDs as String cause terrible issues, so we convert them to integers.\n        newData.id = parseInt(newData.id, 10);\n\n        const insertedData: Data = await Store.insertData(\n          { [model.pluralName]: newData },\n          dispatch\n        );\n\n        // Try to find the record to return\n        const records = insertedData[model.pluralName];\n        const newRecord = records[records.length - 1];\n        if (newRecord) {\n          return newRecord;\n        } else {\n          Context.getInstance().logger.log(\n            \"Couldn't find the record of type '\",\n            model.pluralName,\n            \"' within\",\n            insertedData,\n            \". Falling back to find()\"\n          );\n          return model.baseModel.query().last();\n        }\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Convenience method to get the model from the state.\n   * @param {RootState} state Vuex state\n   * @returns {Model}\n   */\n  static getModelFromState(state: RootState): Model {\n    return Context.getInstance().getModel(state.$name);\n  }\n\n  /**\n   * Makes sure args is a hash.\n   *\n   * @param {Arguments|undefined} args\n   * @param {any} id When not undefined, it's added to the args\n   * @returns {Arguments}\n   */\n  static prepareArgs(args?: Arguments, id?: any): Arguments {\n    args = args || {};\n    if (id) args[\"id\"] = id;\n\n    return args;\n  }\n\n  /**\n   * Adds the record itself to the args and sends it through transformOutgoingData. Key is named by the singular name\n   * of the model.\n   *\n   * @param {Arguments} args\n   * @param {Model} model\n   * @param {Data} data\n   * @returns {Arguments}\n   */\n  static addRecordToArgs(args: Arguments, model: Model, data: Data): Arguments {\n    args[model.singularName] = Transformer.transformOutgoingData(model, data);\n    return args;\n  }\n\n  /**\n   * Transforms each field of the args which contains a model.\n   * @param {Arguments} args\n   * @returns {Arguments}\n   */\n  protected static transformArgs(args: Arguments): Arguments {\n    const context = Context.getInstance();\n\n    Object.keys(args).forEach((key: string) => {\n      const value: any = args[key];\n\n      if (value instanceof context.components.Model) {\n        const model = context.getModel(inflection.singularize(value.$self().entity));\n        const transformedValue = Transformer.transformOutgoingData(model, value);\n        context.logger.log(\n          \"A\",\n          key,\n          \"model was found within the variables and will be transformed from\",\n          value,\n          \"to\",\n          transformedValue\n        );\n        args[key] = transformedValue;\n      }\n    });\n\n    return args;\n  }\n}\n","import { ActionParams } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport { Store } from \"../orm/store\";\n\n/**\n * Destroy action for sending a delete mutation. Will be used for record.$destroy().\n */\nexport default class Destroy extends Action {\n  /**\n   * @param {State} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} id ID of the record to delete\n   * @returns {Promise<any>} true\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { id, args }: ActionParams\n  ): Promise<boolean> {\n    if (id) {\n      const model = this.getModelFromState(state!);\n      const mutationName = NameGenerator.getNameForDestroy(model);\n\n      const mockReturnValue = model.$mockHook(\"destroy\", { id });\n\n      if (mockReturnValue) {\n        await Store.insertData(mockReturnValue, dispatch!);\n        return true;\n      }\n\n      args = this.prepareArgs(args, id);\n\n      await Action.mutation(mutationName, args, dispatch!, model);\n      return true;\n    } else {\n      throw new Error(\"The destroy action requires the 'id' to be set\");\n    }\n  }\n}\n","import QueryBuilder from \"../graphql/query-builder\";\nimport Context from \"../common/context\";\nimport { Store } from \"../orm/store\";\nimport Transformer from \"../graphql/transformer\";\nimport { ActionParams, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\n\n/**\n * Fetch action for sending a query. Will be used for Model.fetch().\n */\nexport default class Fetch extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {ActionParams} params Optional params to send with the query\n   * @returns {Promise<Data>} The fetched records as hash\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    params?: ActionParams\n  ): Promise<Data> {\n    const context = Context.getInstance();\n    const model = this.getModelFromState(state!);\n\n    const mockReturnValue = model.$mockHook(\"fetch\", {\n      filter: params ? params.filter || {} : {}\n    });\n\n    if (mockReturnValue) {\n      return Store.insertData(mockReturnValue, dispatch!);\n    }\n\n    await context.loadSchema();\n\n    // Filter\n    const filter =\n      params && params.filter\n        ? Transformer.transformOutgoingData(model, params.filter, Object.keys(params.filter))\n        : {};\n\n    const bypassCache = params && params.bypassCache;\n\n    // When the filter contains an id, we query in singular mode\n    const multiple: boolean = !filter[\"id\"];\n    const name: string = NameGenerator.getNameForFetch(model, multiple);\n    const query = QueryBuilder.buildQuery(\"query\", model, name, filter, multiple, multiple);\n\n    // Send the request to the GraphQL API\n    const data = await context.apollo.request(model, query, filter, false, bypassCache as boolean);\n\n    // Insert incoming data into the store\n    return Store.insertData(data, dispatch!);\n  }\n}\n","import { ActionParams, Arguments, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport Context from \"../common/context\";\nimport Schema from \"../graphql/schema\";\nimport { Store } from \"../orm/store\";\n\n/**\n * Mutate action for sending a custom mutation. Will be used for Model.mutate() and record.$mutate().\n */\nexport default class Mutate extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} name Name of the query\n   * @param {boolean} multiple Fetch one or multiple?\n   * @param {Arguments} args Arguments for the mutation. Must contain a 'mutation' field.\n   * @returns {Promise<Data>} The new record if any\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { args, name }: ActionParams\n  ): Promise<Data> {\n    if (name) {\n      const context: Context = Context.getInstance();\n      const model = this.getModelFromState(state!);\n\n      const mockReturnValue = model.$mockHook(\"mutate\", {\n        name,\n        args: args || {}\n      });\n\n      if (mockReturnValue) {\n        return Store.insertData(mockReturnValue, dispatch!);\n      }\n\n      const schema: Schema = await context.loadSchema();\n      args = this.prepareArgs(args);\n\n      // There could be anything in the args, but we have to be sure that all records are gone through\n      // transformOutgoingData()\n      this.transformArgs(args);\n\n      // Send the mutation\n      return Action.mutation(name, args, dispatch!, model);\n    } else {\n      throw new Error(\"The mutate action requires the mutation name ('mutation') to be set\");\n    }\n  }\n}\n","import Context from \"../common/context\";\nimport { ActionParams, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport Model from \"../orm/model\";\nimport { Store } from \"../orm/store\";\n\n/**\n * Persist action for sending a create mutation. Will be used for record.$persist().\n */\nexport default class Persist extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} id ID of the record to persist\n   * @returns {Promise<Data>} The saved record\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { id, args }: ActionParams\n  ): Promise<Data> {\n    if (id) {\n      const model = this.getModelFromState(state!);\n      const mutationName = NameGenerator.getNameForPersist(model);\n      const oldRecord = model.getRecordWithId(id);\n\n      const mockReturnValue = model.$mockHook(\"persist\", {\n        id,\n        args: args || {}\n      });\n\n      if (mockReturnValue) {\n        const newRecord = Store.insertData(mockReturnValue, dispatch!);\n        await this.deleteObsoleteRecord(model, newRecord, oldRecord);\n        return newRecord;\n      }\n\n      // Arguments\n      args = this.prepareArgs(args);\n      this.addRecordToArgs(args, model, oldRecord);\n\n      // Send mutation\n      const newRecord = await Action.mutation(mutationName, args, dispatch!, model);\n\n      // Delete the old record if necessary\n      await this.deleteObsoleteRecord(model, newRecord, oldRecord);\n\n      return newRecord;\n    } else {\n      throw new Error(\"The persist action requires the 'id' to be set\");\n    }\n  }\n\n  /**\n   * It's very likely that the server generated different ID for this record.\n   * In this case Action.mutation has inserted a new record instead of updating the existing one.\n   *\n   * @param {Model} model\n   * @param {Data} record\n   * @returns {Promise<void>}\n   */\n  private static async deleteObsoleteRecord(model: Model, newRecord: Data, oldRecord: Data) {\n    if (newRecord && oldRecord && newRecord.id !== oldRecord.id) {\n      Context.getInstance().logger.log(\"Dropping deprecated record\", oldRecord);\n      return oldRecord.$delete();\n    }\n  }\n}\n","import { ActionParams, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport { Store } from \"../orm/store\";\n\n/**\n * Push action for sending a update mutation. Will be used for record.$push().\n */\nexport default class Push extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {Arguments} data New data to save\n   * @param {Arguments} args Additional arguments\n   * @returns {Promise<Data>} The updated record\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { data, args }: ActionParams\n  ): Promise<Data> {\n    if (data) {\n      const model = this.getModelFromState(state!);\n      const mutationName = NameGenerator.getNameForPush(model);\n\n      const mockReturnValue = model.$mockHook(\"push\", {\n        data,\n        args: args || {}\n      });\n\n      if (mockReturnValue) {\n        return Store.insertData(mockReturnValue, dispatch!);\n      }\n\n      // Arguments\n      args = this.prepareArgs(args, data.id);\n      this.addRecordToArgs(args, model, data);\n\n      // Send the mutation\n      return Action.mutation(mutationName, args, dispatch!, model);\n    } else {\n      throw new Error(\"The persist action requires the 'data' to be set\");\n    }\n  }\n}\n","import QueryBuilder from \"../graphql/query-builder\";\nimport Context from \"../common/context\";\nimport { Store } from \"../orm/store\";\nimport Transformer from \"../graphql/transformer\";\nimport { ActionParams, Data } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport NameGenerator from \"../graphql/name-generator\";\nimport Schema from \"../graphql/schema\";\n\n/**\n * Query action for sending a custom query. Will be used for Model.customQuery() and record.$customQuery.\n */\nexport default class Query extends Action {\n  /**\n   * @param {any} state The Vuex state\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} name Name of the query\n   * @param {boolean} multiple Fetch one or multiple?\n   * @param {object} filter Filter object (arguments)\n   * @param {boolean} bypassCache Whether to bypass the cache\n   * @returns {Promise<Data>} The fetched records as hash\n   */\n  public static async call(\n    { state, dispatch }: ActionParams,\n    { name, filter, bypassCache }: ActionParams\n  ): Promise<Data> {\n    if (name) {\n      const context: Context = Context.getInstance();\n      const model = this.getModelFromState(state!);\n\n      const mockReturnValue = model.$mockHook(\"query\", {\n        name,\n        filter: filter || {}\n      });\n\n      if (mockReturnValue) {\n        return Store.insertData(mockReturnValue, dispatch!);\n      }\n\n      const schema: Schema = await context.loadSchema();\n\n      // Filter\n      filter = filter ? Transformer.transformOutgoingData(model, filter) : {};\n\n      // Multiple?\n      const multiple: boolean = Schema.returnsConnection(schema.getQuery(name)!);\n\n      // Build query\n      const query = QueryBuilder.buildQuery(\"query\", model, name, filter, multiple, false);\n\n      // Send the request to the GraphQL API\n      const data = await context.apollo.request(\n        model,\n        query,\n        filter,\n        false,\n        bypassCache as boolean\n      );\n\n      // Insert incoming data into the store\n      return Store.insertData(data, dispatch!);\n    } else {\n      throw new Error(\"The customQuery action requires the query name ('name') to be set\");\n    }\n  }\n}\n","import { ActionParams } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport Context from \"../common/context\";\nimport { parse } from \"graphql/language/parser\";\nimport { clone } from \"../support/utils\";\n\n/**\n * SimpleQuery action for sending a model unrelated simple query.\n */\nexport default class SimpleQuery extends Action {\n  /**\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} query The query to send\n   * @param {Arguments} variables\n   * @param {boolean} bypassCache Whether to bypass the cache\n   * @returns {Promise<any>} The result\n   */\n  public static async call(\n    { dispatch }: ActionParams,\n    { query, bypassCache, variables }: ActionParams\n  ): Promise<any> {\n    const context: Context = Context.getInstance();\n\n    if (query) {\n      const parsedQuery = parse(query);\n      const mockReturnValue = context.globalMockHook(\"simpleQuery\", {\n        name: parsedQuery.definitions[0][\"name\"].value,\n        variables\n      });\n\n      if (mockReturnValue) {\n        return mockReturnValue;\n      }\n\n      variables = this.prepareArgs(variables);\n\n      const result = await context.apollo.simpleQuery(query, variables, bypassCache);\n\n      // remove the symbols\n      return clone(result.data);\n    } else {\n      throw new Error(\"The simpleQuery action requires the 'query' to be set\");\n    }\n  }\n}\n","import { ActionParams } from \"../support/interfaces\";\nimport Action from \"./action\";\nimport Context from \"../common/context\";\nimport { parse } from \"graphql/language/parser\";\nimport { clone } from \"../support/utils\";\n\n/**\n * SimpleMutation action for sending a model unrelated simple mutation.\n */\nexport default class SimpleMutation extends Action {\n  /**\n   * @param {DispatchFunction} dispatch Vuex Dispatch method for the model\n   * @param {string} query The query to send\n   * @param {Arguments} variables\n   * @returns {Promise<any>} The result\n   */\n  public static async call(\n    { dispatch }: ActionParams,\n    { query, variables }: ActionParams\n  ): Promise<any> {\n    const context: Context = Context.getInstance();\n\n    if (query) {\n      const parsedQuery = parse(query);\n      const mockReturnValue = context.globalMockHook(\"simpleMutation\", {\n        name: parsedQuery.definitions[0][\"name\"].value,\n        variables\n      });\n\n      if (mockReturnValue) {\n        return mockReturnValue;\n      }\n\n      variables = this.prepareArgs(variables);\n      const result = await context.apollo.simpleMutation(query, variables);\n\n      // remove the symbols\n      return clone(result.data);\n    } else {\n      throw new Error(\"The simpleMutation action requires the 'query' to be set\");\n    }\n  }\n}\n","import { PatchedModel, Options, ActionParams } from \"./support/interfaces\";\nimport Context from \"./common/context\";\nimport { Components } from \"@vuex-orm/core/lib/plugins/use\";\nimport { Destroy, Fetch, Mutate, Persist, Push } from \"./actions\";\nimport Query from \"./actions/query\";\nimport SimpleQuery from \"./actions/simple-query\";\nimport SimpleMutation from \"./actions/simple-mutation\";\nimport { isPlainObject } from \"./support/utils\";\n\n/**\n * Main class of the plugin. Setups the internal context, Vuex actions and model methods\n */\nexport default class VuexORMGraphQL {\n  /**\n   * @constructor\n   * @param {Components} components The Vuex-ORM Components collection\n   * @param {Options} options The options passed to VuexORM.install\n   */\n  public constructor(components: Components, options: Options) {\n    Context.setup(components, options);\n    VuexORMGraphQL.setupActions();\n    VuexORMGraphQL.setupModelMethods();\n  }\n\n  /**\n   * Allow everything to read the context.\n   */\n  public getContext(): Context {\n    return Context.getInstance();\n  }\n\n  /**\n   * This method will setup following Vuex actions: fetch, persist, push, destroy, mutate\n   */\n  private static setupActions() {\n    const context = Context.getInstance();\n\n    context.components.RootActions.simpleQuery = SimpleQuery.call.bind(SimpleQuery);\n    context.components.RootActions.simpleMutation = SimpleMutation.call.bind(SimpleMutation);\n\n    context.components.Actions.fetch = Fetch.call.bind(Fetch);\n    context.components.Actions.persist = Persist.call.bind(Persist);\n    context.components.Actions.push = Push.call.bind(Push);\n    context.components.Actions.destroy = Destroy.call.bind(Destroy);\n    context.components.Actions.mutate = Mutate.call.bind(Mutate);\n    context.components.Actions.query = Query.call.bind(Query);\n  }\n\n  /**\n   * This method will setup following model methods: Model.fetch, Model.mutate, Model.customQuery, record.$mutate,\n   * record.$persist, record.$push, record.$destroy and record.$deleteAndDestroy, record.$customQuery\n   */\n  private static setupModelMethods() {\n    const context = Context.getInstance();\n\n    // Register static model convenience methods\n    (context.components.Model as typeof PatchedModel).fetch = async function(\n      filter: any,\n      bypassCache = false\n    ) {\n      let filterObj = filter;\n      if (!isPlainObject(filterObj)) filterObj = { id: filter };\n      return this.dispatch(\"fetch\", { filter: filterObj, bypassCache });\n    };\n\n    (context.components.Model as typeof PatchedModel).mutate = async function(\n      params: ActionParams\n    ) {\n      return this.dispatch(\"mutate\", params);\n    };\n\n    (context.components.Model as typeof PatchedModel).customQuery = async function({\n      name,\n      filter,\n      multiple,\n      bypassCache\n    }: ActionParams) {\n      return this.dispatch(\"query\", { name, filter, multiple, bypassCache });\n    };\n\n    // Register model convenience methods\n    const model = context.components.Model.prototype;\n\n    model.$mutate = async function({ name, args, multiple }: ActionParams) {\n      args = args || {};\n      if (!args[\"id\"]) args[\"id\"] = this.id;\n      return this.$dispatch(\"mutate\", { name, args, multiple });\n    };\n\n    model.$customQuery = async function({ name, filter, multiple, bypassCache }: ActionParams) {\n      filter = filter || {};\n      if (!filter[\"id\"]) filter[\"id\"] = this.id;\n      return this.$dispatch(\"query\", { name, filter, multiple, bypassCache });\n    };\n\n    model.$persist = async function(args: any) {\n      return this.$dispatch(\"persist\", { id: this.id, args });\n    };\n\n    model.$push = async function(args: any) {\n      return this.$dispatch(\"push\", { data: this, args });\n    };\n\n    model.$destroy = async function() {\n      return this.$dispatch(\"destroy\", { id: this.id });\n    };\n\n    model.$deleteAndDestroy = async function() {\n      await this.$delete();\n      return this.$destroy();\n    };\n  }\n}\n"],"names":["Object","defineProperty","exports","value","condition","message","Error","undefined","obj","_invariant2","_invariant","__esModule","default","Source","body","name","locationOffset","instance","Constructor","TypeError","_classCallCheck","this","line","column","source","position","lineRegexp","match","exec","index","length","highlightSourceAtLocation","location","lineOffset","columnOffset","getColumnOffset","contextLine","contextColumn","prevLineNum","toString","lineNum","nextLineNum","padLen","lines","split","whitespace","lpad","filter","Boolean","join","len","Array","str","error","printedLocations","nodes","forEach","node","loc","push","_location","getLocation","start","locations","concat","GraphQLError","positions","path","originalError","extensions","_nodes","isArray","_source","_positions","reduce","list","_locations","providedSource","map","pos","defineProperties","enumerable","writable","stack","configurable","captureStackTrace","prototype","create","constructor","_printError","printError","description","_GraphQLError","_extends","assign","target","i","arguments","key","hasOwnProperty","call","get","_syntaxError","syntaxError","_locatedError","locatedError","_formatError","formatError","leadingWhitespace","isBlank","rawString","commonIndent","indent","_i","slice","shift","pop","options","startOfFileToken","Tok","SOF","lastToken","token","lineStart","advance","advanceLexer","lookahead","kind","_blockStringValue2","_blockStringValue","EOF","next","readToken","COMMENT","BANG","DOLLAR","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","NAME","INT","FLOAT","STRING","BLOCK_STRING","charCodeAt","String","end","prev","printCharCode","code","isNaN","JSON","stringify","fromCharCode","toUpperCase","lexer","bodyLength","startPosition","positionAfterWhitespace","col","_error","readComment","readName","firstCode","isFloat","readDigits","readNumber","chunkStart","rawValue","readBlockString","charCode","a","b","c","d","char2hex","readString","unexpectedCharacterMessage","toJSON","inspect","QUERY","MUTATION","SUBSCRIPTION","FIELD","FRAGMENT_DEFINITION","FRAGMENT_SPREAD","INLINE_FRAGMENT","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","parseName","expect","_lexer","TokenKind","_kinds","parseDefinition","peek","parseExecutableDefinition","parseTypeSystemDefinition","peekDescription","unexpected","parseOperationDefinition","expectKeyword","experimentalFragmentVariables","parseFragmentName","variableDefinitions","parseVariableDefinitions","typeCondition","parseNamedType","directives","parseDirectives","selectionSet","parseSelectionSet","parseFragmentDefinition","OPERATION_DEFINITION","operation","parseOperationType","operationToken","many","parseVariableDefinition","VARIABLE_DEFINITION","variable","parseVariable","type","parseTypeReference","defaultValue","skip","parseValueLiteral","VARIABLE","SELECTION_SET","selections","parseSelection","parseFragment","nameOrAlias","alias","parseArguments","parseField","isConst","item","parseConstArgument","parseArgument","ARGUMENT","parseConstValue","parseValueValue","LIST","values","openKind","parseFn","closeKind","any","parseList","fields","parseObjectField","parseObject","parseStringLiteral","BOOLEAN","NULL","block","OBJECT_FIELD","parseDirective","DIRECTIVE","LIST_TYPE","NON_NULL_TYPE","NAMED_TYPE","keywordToken","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","parseSchemaDefinition","parseDescription","SCALAR_TYPE_DEFINITION","parseScalarTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","parseObjectTypeDefinition","INTERFACE_TYPE_DEFINITION","parseInterfaceTypeDefinition","types","parseMemberTypesDefinition","UNION_TYPE_DEFINITION","parseUnionTypeDefinition","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumTypeDefinition","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseInputObjectTypeDefinition","SCALAR_TYPE_EXTENSION","parseScalarTypeExtension","OBJECT_TYPE_EXTENSION","parseObjectTypeExtension","INTERFACE_TYPE_EXTENSION","parseInterfaceTypeExtension","UNION_TYPE_EXTENSION","parseUnionTypeExtension","ENUM_TYPE_EXTENSION","parseEnumTypeExtension","INPUT_OBJECT_TYPE_EXTENSION","parseInputObjectTypeExtension","parseTypeExtension","args","parseArgumentDefs","parseDirectiveLocation","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveDefinition","OPERATION_TYPE_DEFINITION","parseFieldDefinition","parseInputValueDef","INPUT_VALUE_DEFINITION","parseEnumValueDefinition","ENUM_VALUE_DEFINITION","_directiveLocation","DirectiveLocation","startToken","noLocation","Loc","endToken","getTokenDesc","atToken","sourceObj","definitions","DOCUMENT","parseDocument","createLexer","root","visitor","visitorKeys","QueryDocumentKeys","inArray","keys","edits","parent","ancestors","newRoot","isLeaving","isEdited","clone","k","editOffset","ii","editKey","editValue","splice","result","isNode","visitFn","getVisitFn","BREAK","visitors","skipping","enter","fn","apply","leave","typeInfo","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","DirectiveDefinition","maybeNode","kindVisitor","kindSpecificVisitor","specificVisitor","specificKindVisitor","ast","_visitor","visit","printDocASTReducer","op","varDefs","wrap","_ref","_ref2","_ref3","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","isDescription","indexOf","replace","printBlockString","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","_ref22","_ref23","_ref24","_ref25","_ref26","_ref27","_ref28","_ref29","_ref30","_ref31","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","maybeArray","separator","x","array","maybeString","LARGE_ARRAY_SIZE","HASH_UNDEFINED","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","MAX_SAFE_INTEGER","argsTag","arrayTag","asyncTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","nullTag","objectTag","proxyTag","regexpTag","setTag","stringTag","symbolTag","undefinedTag","arrayBufferTag","dataViewTag","reIsHostCtor","reIsUint","typedArrayTags","freeGlobal","global","freeSelf","self","Function","freeExports","nodeType","freeModule","module","moduleExports","freeProcess","process","nodeUtil","binding","e","nodeIsTypedArray","isTypedArray","arraySome","predicate","mapToArray","size","setToArray","set","uid","func","transform","arrayProto","funcProto","objectProto","coreJsData","funcToString","maskSrcKey","IE_PROTO","nativeObjectToString","reIsNative","RegExp","Buffer","Symbol","Uint8Array","propertyIsEnumerable","symToStringTag","toStringTag","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeKeys","arg","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","Hash","entries","clear","entry","ListCache","MapCache","SetCache","__data__","add","Stack","data","arrayLikeKeys","inherited","isArr","isArg","isArguments","isBuff","isType","skipIndexes","n","iteratee","baseTimes","isIndex","assocIndexOf","eq","baseGetTag","isOwn","tag","getRawTag","objectToString","baseIsArguments","isObjectLike","baseIsEqual","other","bitmask","customizer","object","equalFunc","objIsArr","othIsArr","objTag","getTag","othTag","objIsObj","othIsObj","isSameTag","equalArrays","byteLength","byteOffset","buffer","convert","isPartial","stacked","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","objProps","getAllKeys","objLength","othLength","skipCtor","objValue","othValue","compared","objCtor","othCtor","equalObjects","baseIsEqualDeep","baseIsNative","isObject","isFunction","test","baseKeys","Ctor","proto","arrLength","seen","arrValue","othIndex","has","keysFunc","symbolsFunc","offset","arrayPush","baseGetAllKeys","getSymbols","getMapData","getValue","hash","string","pairs","resIndex","arrayFilter","symbol","ArrayBuffer","resolve","ctorString","isLength","baseUnary","upcaseFirstLetter","input","charAt","downcaseFirstLetter","toLowerCase","prettify","query","print","parse","isPlainObject","getPrototypeOf","pick","props","prop","isEqual","lodashIsEqual","enabled","log","console","groupCollapsed","PREFIX","messages","groupEnd","warn","variables","fetchPolicy","prettified","group","trim","inflection","require","baseModel","singularName","singularize","entity","pluralName","pluralize","field","context","Context","getInstance","components","Number","Increment","Attr","BelongsTo","HasOne","MorphTo","MorphOne","model","originalFieldGenerator","bind","originalFields","boolean","Model","isFieldAttribute","_this","skipField","startsWith","skipFields","shouldSkipField","getRelations","relation","foreignKey","relations","found","models","MorphMany","MorphedByMany","MorphToMany","related","id","withAllRecursive","where","first","fieldName","relatedModel","eagerLoad","find","mock","$findMock","action","mocks","m","returnValue","r","$isPersisted","opts","cmp","f","cycles","aobj","bobj","isFinite","out","seenIndex","sort","valueToObjectRepresentation","argObj","isIntValue","isFloatValue","isBooleanValue","isStringValue","isObjectValue","nestedArgObj_1","isVariable","variableValue","isListValue","listValue","nestedArgArrayObj","isEnumValue","isNullValue","KNOWN_DIRECTIVES","getStoreKeyName","filterKeys","queryArgs_1","filteredArgs_1","completeFieldName","stringifiedArgs","argumentsObjectFromField","argObj_1","_a","resultKeyNameFromField","isField","selection","isInlineFragment","isIdValue","idObject","toIdValue","idConfig","generated","typename","shouldInclude","res","directive","directiveArguments","directiveName","ifArgument","ifValue","evaledValue","getDirectiveNames","doc","definition","flattenSelections","selectionNode","selected","getFragmentQueryDocument","document","fragmentName","actualFragmentName","fragments","sources","checkDocument","operations","getOperationDefinition","getOperationName","getFragmentDefinitions","getQueryDefinition","queryDef","createFragmentMap","symTable","fragment","getDefaultValues","defaultValues","defaultValueObj","factory","_typeof","iterator","fclone","refs","Date","subarray","isArrayLike","_l","_copy","copy","l","cloneDeep","TYPENAME_FIELD","removeDirectivesFromDocument","docClone","removeDirectivesFromSelectionSet","agressiveRemove","some","dir","remove","directiveMatcher","getDirectiveMatcher","shouldKeep","isNotEmpty","def","getOperationDefinitionOrDie","addTypenameToDocument","isRoot","addTypenameToSelectionSet","lastIndexOf","connectionRemoveConfig","willRemove","isEnv","env","NODE_ENV","isProduction","isTest","tryFunctionOrLogError","graphQLResultHasError","errors","getTime","NetworkStatus","haveWarned","isNetworkRequestInFlight","networkStatus","_createClass","descriptor","protoProps","staticProps","hasSymbols","hasSymbol","getSymbol","getMethod","getSpecies","ctor","Observable","isObservable","hostReportError","setTimeout","enqueue","then","cleanupSubscription","subscription","cleanup","_cleanup","unsubscribe","closeSubscription","_observer","_queue","_state","notifySubscription","observer","onNotify","queue","flushSubscription","observable","Subscription","subscriber","subscriptionObserver","SubscriptionObserver","_subscription","_subscriber","complete","reject","subscribe","done","_this2","_this3","_this4","C","hasSeed","hasValue","acc","_this5","_len","_key","startNext","v","from","_this6","subscriptions","outer","inner","completeIfDone","closed","s","method","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","err","return","_len2","items","_key2","configurabe","require$$0","link","_super","__extends","isTerminating","request","fromError","errorValue","createOperation","starting","operationName","getKey","passthrough","forward","of","toLink","handler","ApolloLink","empty","links","y","left","right","leftLink","rightLink","second","firstLink","LinkError","nextLink","execute","transformedOperation","transformOperation","OPERATION_FIELDS","validateOperation","ponyfill","window","$$observable","LinkObservable","FetchType","generateErrorMessage","graphQLErrors","graphQLError","errorMessage","networkError","extraInfo","__proto__","ApolloError","scheduler","_b","shouldSubscribe","onSubscribe","isCurrentlyPolling","isTornDown","queryId","queryManager","generateQueryId","observers","subscriptionHandles","ObservableQuery","that","obs","removeQuery","lastError","lastResult","loading","storeValue","policy","queryStoreValue","queryStore","errorPolicy","partial","queryLoading","ready","stale","__assign","isNetworkFetchPolicy","combinedOptions","fetchQuery","refetch","fetchMoreOptions","updateQuery","qid","normal","fetchMoreResult","previousResult","startGraphQLSubscription","subscriptionData","previous","onError","oldOptions","pollInterval","startPolling","stopPolling","tryFetch","setVariables","fetchResults","newVariables","mapFn","newResult","dataStore","markUpdateQueryResult","broadcastQueries","stopPollingQuery","startPollingQuery","setUpQuery","tearDownQuery","addObservableQuery","startQuery","queryListenerForObserver","sub","removeObservableQuery","stopQuery","DedupLink","getContext","forceFetch","toKey","operationKey","inFlightRequestObservables","delete","subscribers","subscription_1","singleObserver_1","sharedObserver","ssrMode","QueryScheduler","fetchType","catch","listener","registeredQueries","addQueryListener","addQueryOnInterval","interval","intervalQueries","checkInFlight","queryOptions","pollingOptions","poll","clearInterval","pollingTimers","setInterval","fetchQueriesOnInterval","MutationStore","store","mutationId","mutationString","mutation","QueryStore","previousQuery","isSetVariables","previousVariables","storePreviousVariables","isPoll","isRefetch","metadata","fetchMoreForQueryId","fetchMore","markQueryResultClient","observableQueryIds","defaultQueryInfo","listeners","invalidated","newData","lastRequestId","observableQuery","queryDeduplication","_c","onBroadcast","_d","deduplicator","Deduplicator","QueryManager","optimisticResponse","updateQueriesByName","refetchQueries","awaitRefetchQueries","updateWithProxyFn","_e","cache","getCache","transformDocument","mutationDef","getMutationDefinition","setQuery","generateUpdateQueriesInfo","ret","queryName","queryIdsByName","updater","mutationStore","initMutation","markMutationInit","updateQueries","update","storeResult","buildOperationForLink","markMutationResult","markMutationError","markMutationComplete","refetchQueryPromises","refetchQueries_1","refetchQuery","promise","refetchQueryByName","all","needToFetch","names","shouldFetch","requestId","generateRequestId","cancel","updateQueryWatch","invalidate","initQuery","networkResult","fetchRequest","markQueryError","removeFetchQueryPromise","previouslyHadError","getLastResult","getLastError","shouldNotifyIfLoading","networkStatusChanged","errorStatusChanged","notifyOnNetworkStatusChange","apolloError_1","info","isMissing","document_1","readResult","diff","optimistic","resultFromStore","queryDefinition","transformedOptions","returnPartialData","idCounter","addFetchQueryPromise","watchQuery","watch","callback","fetchQueryPromises","val","resetIds","queries","reset","clearStore","reFetchObservableQueries","includeStandby","observableQueryPromises","getObservableQueryPromises","isCacheEnabled","transformedDoc","markSubscriptionResult","stopQueryInStore","read","queryIdOrObservable","foundObserveableQuery","resetLastResults","errorsFromStore","markQueryResult","refetchedQueries","getQuery","newInfo","extraContext","transformForLink","getCacheKey","config","dataIdFromObject","initialCache","DataStore","ignoreErrors","writeWithErrors","write","dataId","optimistic_1","recordOptimisticTransaction","orig","cacheWrites_1","currentQueryResult","nextQueryResult","mutationResult","queryVariables","performTransaction","update_1","removeOptimistic","hasSuggestedDevtools","supportedDirectives","ssrForceFetchDelay","connectToDevTools","defaultOptions","disableNetworkFetches","mutate","resetStore","defaultConnectToDevTools","__APOLLO_CLIENT__","top","__APOLLO_DEVTOOLS_GLOBAL_HOOK__","navigator","userAgent","debug","version","ApolloClient","initQueryManager","initProxy","readQuery","readFragment","writeQuery","writeFragment","writeData","cb","devToolsHookCb","payload","state","getStore","mutations","dataWithOptimisticResults","extract","resetStoreCallbacks","serializedState","restore","proxy","selectionSetFromObj","nestedSelSet","justTypenameQuery","ApolloCache","rootId","typenameResult","__typename","dataToWrite","queryFromPojo","HeuristicFragmentMatcher","idValue","msg","warnOnceInDevelopment","ObjectCache","defaultNormalizedCacheFactory","seed","writeResultToStore","storeFactory","fragmentMatcherFunction","operationDefinition","fragmentMap","writeSelectionSetToStore","processedData","enhancedError","WriteError","enhanceErrorWithDocument","included","resultFieldKey","storeObject","storeFieldName","directivesObj","storeKeyNameFromField","shouldMerge","generatedKey","generatedId","processArrayValue","itemDataId","semanticId","isDataProcessed","valueDataId","isGeneratedId","escapedId","hadTypename","hasTypename","typenameChanged","json","newStoreObj","mergeWithGenerated","realKey","real","realValue","writeFieldToStore","substring","matches","fakeContext","hasMissingField","cacheRedirects","graphql","resolver","rootValue","contextValue","variableValues","execOptions","mainDefinition","queryDoc","fragmentDefinition","getMainDefinition","execContext","resultMapper","fragmentMatcher","executeSelectionSet","fieldResult","isLeaf","resultKey","directiveObj_1","getDirectiveInfoFromField","executeSubSelectedArray","executeField","merge","fragmentResult","hasOwn","dest","src","srcVal","ID_KEY","readStoreResolver","assertIdValue","objId","storeKeyName","jsonObject","fieldValue","storeObj","addPreviousResultToIdValues","idToPreviousResult_1","itemPreviousResult","diffQueryAgainstStore","graphqlAnywhere","resultFields","currentResultKeys_1","every","areNestedArrayItemsStrictlyEqual","RecordingCache","transaction","recordedData","defaultConfig","_id","addTypename","customResolvers","cacheResolvers","InMemoryCache","patches","opt","toObject","broadcastWatches","watches","toPerform","change","alreadySilenced","silenceBroadcast","patch","startingState","record","recordingCache","dataCache","typenameDocumentCache","fallbackHttpConfig","http","includeQuery","includeExtensions","headers","accept","content-type","throwServerError","response","statusCode","status","serializeFetchParameter","p","label","serialized","parseError","createHttpLink","linkOptions","uri","fetcher","useGETForQueries","requestOptions","fetch","library","checkFetcher","linkConfig","fetchOptions","credentials","controller","chosenURI","fallbackURI","contextURI","selectURI","contextConfig","fallbackConfig","configs","signal","AbortController","_controller","queryParams","addQueryParam","encodeURIComponent","serializedVariables","serializedExtensions","preFragment","fragmentStart","substr","queryParamsPrefix","newURI","setContext","text","bodyText","abort","whitelist","$entitiy","includes","getModel","arrayModel_1","transformOutgoingData","$id","$self","recursiveCall","logger","transformIncomingData","localModel","connectionQueryMode","edges","newKey","isFieldNumber","parseFloat","endsWith","isTypeFieldOfPolymorphicRelation","parser","normalize","docCache","fragmentSourceMap","printFragmentWarnings","cacheKey","parsed","stripLoc","removeLocAtThisLevel","docType","valueType","astFragmentMap","sourceKey","processFragments","gql","literals","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","httpLink","HttpLink","url","apolloClient","debugMode","bypassCache","logQuery","Apollo","getHeaders","Transformer","schema","t","getType","connection","typeName","Schema","getTypeNameOfField","allowNull","getRealType","ofType","database","Logger","apollo","collectModels","schemaWillBeLoaded","X-GraphQL-Introspection-Query","simpleQuery","__schema","processSchema","determineQueryMode","name_1","findGlobalMock","globalMocks","entities","augment","multiple","allowIdFields","getMutation","params","buildArguments","getQueryFields","buildRelationsQuery","header","__type","buildField","signature","isForeignKey","skipFieldDueId","schemaField","findSchemaFieldForArgument","isConnectionField","typeOrValue","QueryBuilder","determineAttributeType","isFilter","inputFields","relationQueries","referencesItSelf","takeWhile","reverse","ignore","shouldEagerLoadRelation","newPath","isConnection","dispatch","dataKey","insertedData","getCRUDName","plural","loadSchema","returnsConnection","buildQuery","NameGenerator","getNameForDestroy","parseInt","Store","insertData","records","newRecord","last","$name","transformedValue","getModelFromState","$mockHook","mockReturnValue","prepareArgs","Action","mutationName","getNameForFetch","transformArgs","getNameForPersist","getRecordWithId","deleteObsoleteRecord","newRecord_1","oldRecord","addRecordToArgs","$delete","getNameForPush","globalMockHook","parsedQuery","simpleMutation","setup","setupActions","setupModelMethods","RootActions","SimpleQuery","SimpleMutation","Actions","Fetch","persist","Persist","Push","destroy","Destroy","Mutate","Query","filterObj","customQuery","$mutate","$dispatch","$customQuery","$persist","$push","$destroy","$deleteAndDestroy"],"mappings":"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"}